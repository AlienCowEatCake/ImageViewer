From 6e51e3bab1ef2a140fc17d97bfc94a29e7340034 Mon Sep 17 00:00:00 2001
From: Peter Zhigalov <peter.zhigalov@gmail.com>
Date: Sun, 17 Jun 2018 19:52:22 +0700
Subject: [PATCH 2/4] Dont use modern options with old Qt verson

---
 src/plugins/imageformats/dds/qddshandler.cpp  |  7 ++++++-
 src/plugins/imageformats/jp2/qjp2handler.cpp  |  7 +++++++
 .../imageformats/webp/qwebphandler.cpp        | 20 +++++++++++++++++++
 3 files changed, 33 insertions(+), 1 deletion(-)

diff --git a/src/plugins/imageformats/dds/qddshandler.cpp b/src/plugins/imageformats/dds/qddshandler.cpp
index 3a44b51..dab69d5 100644
--- a/src/plugins/imageformats/dds/qddshandler.cpp
+++ b/src/plugins/imageformats/dds/qddshandler.cpp
@@ -1489,8 +1489,10 @@ QVariant QDDSHandler::option(QImageIOHandler::ImageOption option) const
         return QSize(m_header.width, m_header.height);
     case QImageIOHandler::SubType:
         return formatName(m_format);
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 4, 0))
     case QImageIOHandler::SupportedSubTypes:
         return QVariant::fromValue(QList<QByteArray>() << formatName(FormatA8R8G8B8));
+#endif
     default:
         break;
     }
@@ -1512,7 +1514,10 @@ bool QDDSHandler::supportsOption(QImageIOHandler::ImageOption option) const
 {
     return (option == QImageIOHandler::Size)
             || (option == QImageIOHandler::SubType)
-            || (option == QImageIOHandler::SupportedSubTypes);
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 4, 0))
+            || (option == QImageIOHandler::SupportedSubTypes)
+#endif
+            ;
 }
 
 int QDDSHandler::imageCount() const
diff --git a/src/plugins/imageformats/jp2/qjp2handler.cpp b/src/plugins/imageformats/jp2/qjp2handler.cpp
index 17373fd..da74fb2 100644
--- a/src/plugins/imageformats/jp2/qjp2handler.cpp
+++ b/src/plugins/imageformats/jp2/qjp2handler.cpp
@@ -589,7 +589,14 @@ bool Jpeg2000JasperReader::read(QImage *pImage)
         if (hasAlpha) {
             qtImage = QImage(qtWidth, qtHeight, QImage::Format_ARGB32);
         } else {
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
             qtImage = QImage(qtWidth, qtHeight, QImage::Format_Grayscale8);
+#else
+            qtImage = QImage(qtWidth, qtHeight, QImage::Format_Indexed8);
+            qtImage.setColorCount(256);
+            for (int c = 0; c < 256; ++c)
+                qtImage.setColor(c, qRgb(c,c,c));
+#endif
         }
     }
 
diff --git a/src/plugins/imageformats/webp/qwebphandler.cpp b/src/plugins/imageformats/webp/qwebphandler.cpp
index 578a701..d861db4 100644
--- a/src/plugins/imageformats/webp/qwebphandler.cpp
+++ b/src/plugins/imageformats/webp/qwebphandler.cpp
@@ -177,7 +177,11 @@ bool QWebpHandler::read(QImage *image)
     QImage::Format format = m_features.has_alpha ? QImage::Format_ARGB32 : QImage::Format_RGB32;
     QImage frame(m_iter.width, m_iter.height, format);
     uint8_t *output = frame.bits();
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 10, 0))
     size_t output_size = frame.sizeInBytes();
+#else
+    size_t output_size = frame.byteCount();
+#endif
 #if Q_BYTE_ORDER == Q_LITTLE_ENDIAN
     if (!WebPDecodeBGRAInto(
         reinterpret_cast<const uint8_t*>(m_iter.fragment.bytes), m_iter.fragment.size,
@@ -221,7 +225,11 @@ bool QWebpHandler::write(const QImage &image)
 
     QImage srcImage = image;
     bool alpha = srcImage.hasAlphaChannel();
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 2, 0))
     QImage::Format newFormat = alpha ? QImage::Format_RGBA8888 : QImage::Format_RGB888;
+#else
+    QImage::Format newFormat = alpha ? QImage::Format_ARGB32 : QImage::Format_RGB32;
+#endif
     if (srcImage.format() != newFormat)
         srcImage = srcImage.convertToFormat(newFormat);
 
@@ -237,10 +245,22 @@ bool QWebpHandler::write(const QImage &image)
     picture.height = srcImage.height();
     picture.use_argb = 1;
     bool failed = false;
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 2, 0))
     if (alpha)
         failed = !WebPPictureImportRGBA(&picture, srcImage.bits(), srcImage.bytesPerLine());
     else
         failed = !WebPPictureImportRGB(&picture, srcImage.bits(), srcImage.bytesPerLine());
+#else
+# if Q_BYTE_ORDER == Q_LITTLE_ENDIAN
+    if (alpha)
+        failed = !WebPPictureImportBGRA(&picture, srcImage.bits(), srcImage.bytesPerLine());
+    else
+        failed = !WebPPictureImportBGRX(&picture, srcImage.bits(), srcImage.bytesPerLine());
+# else /* Q_BIG_ENDIAN */
+    qWarning() << "QWebpHandler::write is not implemented for big endian systems with Qt < 5.2";
+    failed = true;
+# endif
+#endif
 
     if (failed) {
         qWarning() << "failed to import image data to webp picture.";
-- 
2.17.1

