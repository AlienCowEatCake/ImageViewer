diff -Nur exiv2-0.27.0-Source.orig/src/convert.cpp exiv2-0.27.0-Source/src/convert.cpp
--- exiv2-0.27.0-Source.orig/src/convert.cpp	2019-01-05 04:51:29.000000000 +0700
+++ exiv2-0.27.0-Source/src/convert.cpp	2019-01-05 06:26:30.000000000 +0700
@@ -56,6 +56,14 @@
 # include <errno.h>
 #endif
 
+#if !(defined WIN32 && !defined __CYGWIN__) && !defined EXV_HAVE_ICONV
+# define EXV_HAVE_QT
+# include <QByteArray>
+# include <QString>
+# include <QTextCodec>
+# include <QMap>
+#endif
+
 // Adobe XMP Toolkit
 #ifdef EXV_HAVE_XMP_TOOLKIT
 # define TXMP_STRING_TYPE std::string
@@ -78,6 +86,10 @@
     // Convert string charset with iconv.
     bool convertStringCharsetIconv(std::string& str, const char* from, const char* to);
 #endif
+#if defined EXV_HAVE_QT
+    // Convert string charset with QTextCodec.
+    bool convertStringCharsetQTextCodec(std::string& str, const char* from, const char* to);
+#endif
     /*!
       @brief Get the text value of an XmpDatum \em pos.
 
@@ -1352,6 +1364,8 @@
         ret = convertStringCharsetIconv(str, from, to);
 #elif defined WIN32 && !defined __CYGWIN__
         ret = convertStringCharsetWindows(str, from, to);
+#elif defined EXV_HAVE_QT
+        ret = convertStringCharsetQTextCodec(str, from, to);
 #else
 # ifndef SUPPRESS_WARNINGS
         EXV_WARNING << "Charset conversion required but no character mapping functionality available.\n";
@@ -1569,6 +1583,43 @@
     }
 
 #endif // EXV_HAVE_ICONV
+#if defined EXV_HAVE_QT
+    static QTextCodec* codecForCharset(const char* charset)
+    {
+        if (QTextCodec* codec = QTextCodec::codecForName(charset))
+            return codec;
+
+        QMap<QByteArray, QByteArray> codecsMap;
+        codecsMap["UTF-8"]      = "UTF-8";
+        codecsMap["UCS-2BE"]    = "UTF-16BE";
+        codecsMap["UCS-2LE"]    = "UTF-16LE";
+        codecsMap["ISO-8859-1"] = "ISO-8859-1";
+        codecsMap["ASCII"]      = "ISO-8859-1";
+
+        QMap<QByteArray, QByteArray>::ConstIterator it = codecsMap.find(charset);
+        if (it != codecsMap.constEnd())
+            return QTextCodec::codecForName(it.value());
+
+        return NULL;
+    }
+
+    bool convertStringCharsetQTextCodec(std::string& str, const char* from, const char* to)
+    {
+        if (strcmp(from, to) == 0)
+            return true;
+
+        QTextCodec* inCodec = codecForCharset(from);
+        QTextCodec* outCodec = codecForCharset(to);
+        if (!inCodec || !outCodec)
+            return false;
+
+        const QByteArray inArray = QByteArray(str.c_str(), static_cast<int>(str.length()));
+        const QByteArray outArray = outCodec->fromUnicode(inCodec->toUnicode(inArray));
+        str = std::string(outArray.constData(), static_cast<size_t>(outArray.size()));
+        return true;
+    }
+
+#endif // EXV_HAVE_QT
     bool getTextValue(std::string& value, const XmpData::iterator& pos)
     {
         if (pos->typeId() == langAlt) {
