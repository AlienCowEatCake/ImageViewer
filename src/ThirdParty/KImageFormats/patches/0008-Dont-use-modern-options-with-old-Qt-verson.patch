From d671852ecff32f544bfdb592e4a9b63ce01bf50c Mon Sep 17 00:00:00 2001
From: Peter Zhigalov <peter.zhigalov@gmail.com>
Date: Sat, 9 Aug 2025 21:12:08 +0700
Subject: [PATCH 8/8] Dont use modern options with old Qt verson

---
 src/imageformats/ani.cpp       |   4 +
 src/imageformats/ani_p.h       |  16 ++++
 src/imageformats/chunks.cpp    |  96 ++++++++++++++++++------
 src/imageformats/chunks_p.h    |  31 ++++++++
 src/imageformats/dds.cpp       | 133 +++++++++++++++++++++++++++++++++
 src/imageformats/exr.cpp       |  38 ++++++++++
 src/imageformats/hdr.cpp       |  27 ++++++-
 src/imageformats/iff.cpp       |  12 ++-
 src/imageformats/jp2.cpp       |  12 +++
 src/imageformats/jxl.cpp       |  43 ++++++++++-
 src/imageformats/jxl_p.h       |   8 ++
 src/imageformats/jxr.cpp       |  19 ++++-
 src/imageformats/microexif.cpp |  32 ++++++++
 src/imageformats/pcx.cpp       |   2 +-
 src/imageformats/pfm.cpp       |  26 +++++++
 src/imageformats/pic.cpp       |   2 +-
 src/imageformats/psd.cpp       |  40 ++++++++++
 src/imageformats/pxr.cpp       |   2 +-
 src/imageformats/ras.cpp       |  14 +++-
 src/imageformats/rgb.cpp       |  26 ++++++-
 src/imageformats/tga.cpp       |   9 ++-
 src/imageformats/util_p.h      |   7 ++
 src/imageformats/xcf.cpp       |  43 ++++++++++-
 23 files changed, 604 insertions(+), 38 deletions(-)

diff --git a/src/imageformats/ani.cpp b/src/imageformats/ani.cpp
index 9c5a935..2adb9f6 100644
--- a/src/imageformats/ani.cpp
+++ b/src/imageformats/ani.cpp
@@ -381,7 +381,11 @@ bool ANIHandler::ensureScanned() const
             }
 
             // TODO should we check that the number of rate entries matches nSteps?
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
             QList<int> list;
+#else
+            QVector<int> list;
+#endif
             for (unsigned int i = 0; i < chunkSize; i += sizeof(quint32_le)) {
                 const QByteArray data = device()->read(sizeof(quint32_le));
                 if (data.size() != sizeof(quint32_le)) {
diff --git a/src/imageformats/ani_p.h b/src/imageformats/ani_p.h
index bfce9ef..7b8435b 100644
--- a/src/imageformats/ani_p.h
+++ b/src/imageformats/ani_p.h
@@ -10,6 +10,10 @@
 #include <QImageIOPlugin>
 #include <QSize>
 
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
+
 class ANIHandler : public QImageIOHandler
 {
 public:
@@ -41,14 +45,26 @@ private:
     int m_frameCount = 0; // "physical" frames
     int m_imageCount = 0; // logical images
     // Stores a custom sequence of images
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<int> m_imageSequence;
+#else
+    QVector<int> m_imageSequence;
+#endif
     // and the corresponding offsets where they are
     // since we can't read the image data sequentally in this case then
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<qint64> m_frameOffsets;
+#else
+    QVector<qint64> m_frameOffsets;
+#endif
     qint64 m_firstFrameOffset = 0;
 
     int m_displayRate = 0;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<int> m_displayRates;
+#else
+    QVector<int> m_displayRates;
+#endif
 
     QString m_name;
     QString m_artist;
diff --git a/src/imageformats/chunks.cpp b/src/imageformats/chunks.cpp
index d36e263..9832074 100644
--- a/src/imageformats/chunks.cpp
+++ b/src/imageformats/chunks.cpp
@@ -30,7 +30,11 @@ static QString dataToString(const IFFChunk *chunk)
         return {};
     }
     auto dt = chunk->data();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
     for (; dt.endsWith(char()); dt = dt.removeLast());
+#else
+    for (; dt.endsWith(char()) && !dt.isEmpty(); dt.remove(dt.size() - 1, 1));
+#endif
     return QString::fromUtf8(dt).trimmed();
 }
 
@@ -518,7 +522,11 @@ qint32 CMAPChunk::count() const
     return bytes() / 3;
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> CMAPChunk::palette(bool halfbride) const
+#else
+QVector<QRgb> CMAPChunk::palette(bool halfbride) const
+#endif
 {
     auto p = innerPalette();
     if (!halfbride) {
@@ -536,9 +544,17 @@ bool CMAPChunk::innerReadStructure(QIODevice *d)
     return cacheData(d);
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> CMAPChunk::innerPalette() const
+#else
+QVector<QRgb> CMAPChunk::innerPalette() const
+#endif
 {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> l;
+#else
+    QVector<QRgb> l;
+#endif
     auto &&d = data();
     for (qint32 i = 0, n = count(); i < n; ++i) {
         auto i3 = i * 3;
@@ -575,9 +591,17 @@ qint32 CMYKChunk::count() const
     return bytes() / 4;
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> CMYKChunk::innerPalette() const
+#else
+QVector<QRgb> CMYKChunk::innerPalette() const
+#endif
 {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> l;
+#else
+    QVector<QRgb> l;
+#endif
     auto &&d = data();
     for (qint32 i = 0, n = count(); i < n; ++i) {
         auto i4 = i * 4;
@@ -1050,21 +1074,21 @@ QByteArray BODYChunk::deinterleave(const QByteArray &planes, qint32 y, const BMH
                 for (qint32 k = 0, i8 = i * 8; k < bitplanes; ++k) {
                     auto v = planes.at(k * rowLen + i);
                     if (v & (1 << 7))
-                        ba[i8] |= 1 << k;
+                        ba[i8 + 0] = ba[i8 + 0] | (1 << k);
                     if (v & (1 << 6))
-                        ba[i8 + 1] |= 1 << k;
+                        ba[i8 + 1] = ba[i8 + 1] | (1 << k);
                     if (v & (1 << 5))
-                        ba[i8 + 2] |= 1 << k;
+                        ba[i8 + 2] = ba[i8 + 2] | (1 << k);
                     if (v & (1 << 4))
-                        ba[i8 + 3] |= 1 << k;
+                        ba[i8 + 3] = ba[i8 + 3] | (1 << k);
                     if (v & (1 << 3))
-                        ba[i8 + 4] |= 1 << k;
+                        ba[i8 + 4] = ba[i8 + 4] | (1 << k);
                     if (v & (1 << 2))
-                        ba[i8 + 5] |= 1 << k;
+                        ba[i8 + 5] = ba[i8 + 5] | (1 << k);
                     if (v & (1 << 1))
-                        ba[i8 + 6] |= 1 << k;
+                        ba[i8 + 6] = ba[i8 + 6] | (1 << k);
                     if (v & 1)
-                        ba[i8 + 7] |= 1 << k;
+                        ba[i8 + 7] = ba[i8 + 7] | (1 << k);
                 }
             }
         }
@@ -1086,21 +1110,21 @@ QByteArray BODYChunk::deinterleave(const QByteArray &planes, qint32 y, const BMH
                     auto k8 = k * 8;
                     auto msk = (1 << (7 - j));
                     if (planes.at(k8 * rowLen + i) & msk)
-                        ba[cnt] |= 0x01;
+                        ba[cnt] = ba[cnt] | 0x01;
                     if (planes.at((1 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x02;
+                        ba[cnt] = ba[cnt] | 0x02;
                     if (planes.at((2 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x04;
+                        ba[cnt] = ba[cnt] | 0x04;
                     if (planes.at((3 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x08;
+                        ba[cnt] = ba[cnt] | 0x08;
                     if (planes.at((4 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x10;
+                        ba[cnt] = ba[cnt] | 0x10;
                     if (planes.at((5 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x20;
+                        ba[cnt] = ba[cnt] | 0x20;
                     if (planes.at((6 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x40;
+                        ba[cnt] = ba[cnt] | 0x40;
                     if (planes.at((7 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x80;
+                        ba[cnt] = ba[cnt] | 0x80;
                 }
         }
         break;
@@ -1141,21 +1165,21 @@ QByteArray BODYChunk::deinterleave(const QByteArray &planes, qint32 y, const BMH
                     auto msk = (1 << (7 - j));
                     auto idx = cnt + order[k];
                     if (planes.at(k8 * rowLen + i) & msk)
-                        ba[idx] |= 0x01;
+                        ba[idx] = ba[idx] | 0x01;
                     if (planes.at((1 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x02;
+                        ba[idx] = ba[idx] | 0x02;
                     if (planes.at((2 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x04;
+                        ba[idx] = ba[idx] | 0x04;
                     if (planes.at((3 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x08;
+                        ba[idx] = ba[idx] | 0x08;
                     if (planes.at((4 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x10;
+                        ba[idx] = ba[idx] | 0x10;
                     if (planes.at((5 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x20;
+                        ba[idx] = ba[idx] | 0x20;
                     if (planes.at((6 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x40;
+                        ba[idx] = ba[idx] | 0x40;
                     if (planes.at((7 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x80;
+                        ba[idx] = ba[idx] | 0x80;
                 }
                 if (p == 6) { // RGBX wants unused X data set to 0xFF
                     ba[cnt + 6] = char(0xFF);
@@ -2320,7 +2344,11 @@ bool BEAMChunk::isValid() const
     return chunkId() == BEAMChunk::defaultChunkId();
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> BEAMChunk::palette(qint32 y, qint32 height) const
+#else
+QVector<QRgb> BEAMChunk::palette(qint32 y, qint32 height) const
+#endif
 {
     if (height < 1) {
         return {};
@@ -2331,7 +2359,11 @@ QList<QRgb> BEAMChunk::palette(qint32 y, qint32 height) const
     }
     auto col = qint32(bpp / 2);
     auto &&dt = data();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> pal;
+#else
+    QVector<QRgb> pal;
+#endif
     for (auto c = 0; c < col; ++c) {
         // 2 bytes per color (0x0R 0xGB)
         auto idx = bpp * y + c * 2;
@@ -2398,7 +2430,11 @@ bool SHAMChunk::isValid() const
     return chunkId() == SHAMChunk::defaultChunkId();
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> SHAMChunk::palette(qint32 y, qint32 height) const
+#else
+QVector<QRgb> SHAMChunk::palette(qint32 y, qint32 height) const
+#endif
 {
     if (height < 1) {
         return {};
@@ -2414,7 +2450,11 @@ QList<QRgb> SHAMChunk::palette(qint32 y, qint32 height) const
         return {};
     }
     auto &&dt = data();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> pal;
+#else
+    QVector<QRgb> pal;
+#endif
     for (auto c = 0, col = bpp / 2, idx0 = y / div * bpp + 2; c < col; ++c) {
         // 2 bytes per color (0x0R 0xGB)
         auto idx = idx0 + c * 2;
@@ -2450,7 +2490,11 @@ bool RASTChunk::isValid() const
     return chunkId() == RASTChunk::defaultChunkId();
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> RASTChunk::palette(qint32 y, qint32 height) const
+#else
+QVector<QRgb> RASTChunk::palette(qint32 y, qint32 height) const
+#endif
 {
     if (height < 1) {
         return {};
@@ -2461,7 +2505,11 @@ QList<QRgb> RASTChunk::palette(qint32 y, qint32 height) const
     }
     auto col = qint32(bpp / 2 - 1);
     auto &&dt = data();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> pal;
+#else
+    QVector<QRgb> pal;
+#endif
     for (auto c = 0; c < col; ++c) {
         auto idx = bpp * y + 2 + c * 2;
         // The Atari ST uses 3 bits per color (512 colors) while the Atari STE
diff --git a/src/imageformats/chunks_p.h b/src/imageformats/chunks_p.h
index 6560ee0..9ccb551 100644
--- a/src/imageformats/chunks_p.h
+++ b/src/imageformats/chunks_p.h
@@ -23,6 +23,9 @@
 #include <QPoint>
 #include <QSize>
 #include <QSharedPointer>
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
 
 #include "microexif_p.h"
 
@@ -358,7 +361,11 @@ class IPALChunk : public IFFChunk
 public:
     virtual ~IPALChunk() override {}
     IPALChunk() : IFFChunk() {}
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> palette(qint32 y, qint32 height) const = 0;
+#else
+    virtual QVector<QRgb> palette(qint32 y, qint32 height) const = 0;
+#endif
 };
 
 
@@ -511,12 +518,20 @@ public:
      * \return The color palette.
      * \note If \a halfbride is true, the returned palette size is count() * 2.
      */
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> palette(bool halfbride = false) const;
+#else
+    QVector<QRgb> palette(bool halfbride = false) const;
+#endif
 
     CHUNKID_DEFINE(CMAP_CHUNK)
 
 protected:
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> innerPalette() const;
+#else
+    virtual QVector<QRgb> innerPalette() const;
+#endif
 
     virtual bool innerReadStructure(QIODevice *d) override;
 };
@@ -554,7 +569,11 @@ protected:
      * \brief palette
      * \return The CMYK color palette converted to RGB one.
      */
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> innerPalette() const override;
+#else
+    virtual QVector<QRgb> innerPalette() const override;
+#endif
 };
 
 /*!
@@ -1312,7 +1331,11 @@ public:
 
     virtual bool isValid() const override;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> palette(qint32 y, qint32 height) const override;
+#else
+    virtual QVector<QRgb> palette(qint32 y, qint32 height) const override;
+#endif
 
     CHUNKID_DEFINE(BEAM_CHUNK)
 
@@ -1349,7 +1372,11 @@ public:
 
     virtual bool isValid() const override;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> palette(qint32 y, qint32 height) const override;
+#else
+    virtual QVector<QRgb> palette(qint32 y, qint32 height) const override;
+#endif
 
     CHUNKID_DEFINE(SHAM_CHUNK)
 
@@ -1373,7 +1400,11 @@ public:
 
     virtual bool isValid() const override;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> palette(qint32 y, qint32 height) const override;
+#else
+    virtual QVector<QRgb> palette(qint32 y, qint32 height) const override;
+#endif
 
     CHUNKID_DEFINE(RAST_CHUNK)
 
diff --git a/src/imageformats/dds.cpp b/src/imageformats/dds.cpp
index acedbd0..f7454b3 100644
--- a/src/imageformats/dds.cpp
+++ b/src/imageformats/dds.cpp
@@ -16,6 +16,11 @@
 #include <QColorSpace>
 #include <QDataStream>
 #include <QDebug>
+#include <QFloat16>
+
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
 
 #include <cmath>
 
@@ -1049,6 +1054,7 @@ static inline float readFloat32(QDataStream &s)
 
 static QImage readR16F(QDataStream &s, const quint32 width, const quint32 height)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     QImage image = imageAlloc(width, height, QImage::Format_RGBX16FPx4);
     if (image.isNull()) {
         return image;
@@ -1065,6 +1071,22 @@ static QImage readR16F(QDataStream &s, const quint32 width, const quint32 height
                 return QImage();
         }
     }
+#else
+    QImage image = imageAlloc(width, height, QImage::Format_RGB32);
+    if (image.isNull()) {
+        return image;
+    }
+
+    for (quint32 y = 0; y < height; y++) {
+        QRgb *line = reinterpret_cast<QRgb *>(image.scanLine(y));
+        for (quint32 x = 0; x < width; x++) {
+            const int r = qBound<int>(0, static_cast<int>(readFloat16(s) * 255.0f), 255);
+            line[x] = qRgb(r, 0, 0);
+            if (s.status() != QDataStream::Ok)
+                return QImage();
+        }
+    }
+#endif
 
     image.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
     return image;
@@ -1072,6 +1094,7 @@ static QImage readR16F(QDataStream &s, const quint32 width, const quint32 height
 
 static QImage readRG16F(QDataStream &s, const quint32 width, const quint32 height)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     QImage image = imageAlloc(width, height, QImage::Format_RGBX16FPx4);
     if (image.isNull()) {
         return image;
@@ -1088,6 +1111,23 @@ static QImage readRG16F(QDataStream &s, const quint32 width, const quint32 heigh
                 return QImage();
         }
     }
+#else
+    QImage image = imageAlloc(width, height, QImage::Format_RGB32);
+    if (image.isNull()) {
+        return image;
+    }
+
+    for (quint32 y = 0; y < height; y++) {
+        QRgb *line = reinterpret_cast<QRgb *>(image.scanLine(y));
+        for (quint32 x = 0; x < width; x++) {
+            const int r = qBound<int>(0, static_cast<int>(readFloat16(s) * 255.0f), 255);
+            const int g = qBound<int>(0, static_cast<int>(readFloat16(s) * 255.0f), 255);
+            line[x] = qRgb(r, g, 0);
+            if (s.status() != QDataStream::Ok)
+                return QImage();
+        }
+    }
+#endif
 
     image.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
     return image;
@@ -1095,6 +1135,7 @@ static QImage readRG16F(QDataStream &s, const quint32 width, const quint32 heigh
 
 static QImage readARGB16F(QDataStream &s, const quint32 width, const quint32 height, bool alphaPremul)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     QImage image = imageAlloc(width, height, alphaPremul ? QImage::Format_RGBA16FPx4_Premultiplied : QImage::Format_RGBA16FPx4);
     if (image.isNull()) {
         return image;
@@ -1111,6 +1152,29 @@ static QImage readARGB16F(QDataStream &s, const quint32 width, const quint32 hei
                 return QImage();
         }
     }
+#else
+    QImage image = imageAlloc(width, height, QImage::Format_ARGB32);
+    if (image.isNull()) {
+        return image;
+    }
+
+    for (quint32 y = 0; y < height; y++) {
+        QRgb *line = reinterpret_cast<QRgb *>(image.scanLine(y));
+        for (quint32 x = 0; x < width; x++) {
+            const float rf = readFloat16(s);
+            const float gf = readFloat16(s);
+            const float bf = readFloat16(s);
+            const float af = readFloat16(s);
+            const int r = qBound<int>(0, static_cast<int>((alphaPremul ? (rf / af) : rf) * 255.0f), 255);
+            const int g = qBound<int>(0, static_cast<int>((alphaPremul ? (gf / af) : gf) * 255.0f), 255);
+            const int b = qBound<int>(0, static_cast<int>((alphaPremul ? (bf / af) : bf) * 255.0f), 255);
+            const int a = qBound<int>(0, static_cast<int>(af * 255.0f), 255);
+            line[x] = qRgba(r, g, b, a);
+            if (s.status() != QDataStream::Ok)
+                return QImage();
+        }
+    }
+#endif
 
     image.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
     return image;
@@ -1118,6 +1182,7 @@ static QImage readARGB16F(QDataStream &s, const quint32 width, const quint32 hei
 
 static QImage readR32F(QDataStream &s, const quint32 width, const quint32 height)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     QImage image = imageAlloc(width, height, QImage::Format_RGBX32FPx4);
     if (image.isNull()) {
         return image;
@@ -1134,6 +1199,22 @@ static QImage readR32F(QDataStream &s, const quint32 width, const quint32 height
                 return QImage();
         }
     }
+#else
+    QImage image = imageAlloc(width, height, QImage::Format_RGB32);
+    if (image.isNull()) {
+        return image;
+    }
+
+    for (quint32 y = 0; y < height; y++) {
+        QRgb *line = reinterpret_cast<QRgb *>(image.scanLine(y));
+        for (quint32 x = 0; x < width; x++) {
+            const int r = qBound<int>(0, static_cast<int>(readFloat32(s) * 255.0f), 255);
+            line[x] = qRgb(r, 0, 0);
+            if (s.status() != QDataStream::Ok)
+                return QImage();
+        }
+    }
+#endif
 
     image.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
     return image;
@@ -1141,6 +1222,7 @@ static QImage readR32F(QDataStream &s, const quint32 width, const quint32 height
 
 static QImage readRG32F(QDataStream &s, const quint32 width, const quint32 height)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     QImage image = imageAlloc(width, height, QImage::Format_RGBX32FPx4);
     if (image.isNull()) {
         return image;
@@ -1157,6 +1239,23 @@ static QImage readRG32F(QDataStream &s, const quint32 width, const quint32 heigh
                 return QImage();
         }
     }
+#else
+    QImage image = imageAlloc(width, height, QImage::Format_RGB32);
+    if (image.isNull()) {
+        return image;
+    }
+
+    for (quint32 y = 0; y < height; y++) {
+        QRgb *line = reinterpret_cast<QRgb *>(image.scanLine(y));
+        for (quint32 x = 0; x < width; x++) {
+            const int r = qBound<int>(0, static_cast<int>(readFloat32(s) * 255.0f), 255);
+            const int g = qBound<int>(0, static_cast<int>(readFloat32(s) * 255.0f), 255);
+            line[x] = qRgb(r, g, 0);
+            if (s.status() != QDataStream::Ok)
+                return QImage();
+        }
+    }
+#endif
 
     image.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
     return image;
@@ -1164,6 +1263,7 @@ static QImage readRG32F(QDataStream &s, const quint32 width, const quint32 heigh
 
 static QImage readARGB32F(QDataStream &s, const quint32 width, const quint32 height, bool alphaPremul)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     QImage image = imageAlloc(width, height, alphaPremul ? QImage::Format_RGBA32FPx4_Premultiplied : QImage::Format_RGBA32FPx4);
     if (image.isNull()) {
         return image;
@@ -1180,6 +1280,29 @@ static QImage readARGB32F(QDataStream &s, const quint32 width, const quint32 hei
                 return QImage();
         }
     }
+#else
+    QImage image = imageAlloc(width, height, QImage::Format_ARGB32);
+    if (image.isNull()) {
+        return image;
+    }
+
+    for (quint32 y = 0; y < height; y++) {
+        QRgb *line = reinterpret_cast<QRgb *>(image.scanLine(y));
+        for (quint32 x = 0; x < width; x++) {
+            const float rf = readFloat32(s);
+            const float gf = readFloat32(s);
+            const float bf = readFloat32(s);
+            const float af = readFloat32(s);
+            const int r = qBound<int>(0, static_cast<int>((alphaPremul ? (rf / af) : rf) * 255.0f), 255);
+            const int g = qBound<int>(0, static_cast<int>((alphaPremul ? (gf / af) : gf) * 255.0f), 255);
+            const int b = qBound<int>(0, static_cast<int>((alphaPremul ? (bf / af) : bf) * 255.0f), 255);
+            const int a = qBound<int>(0, static_cast<int>(af * 255.0f), 255);
+            line[x] = qRgba(r, g, b, a);
+            if (s.status() != QDataStream::Ok)
+                return QImage();
+        }
+    }
+#endif
 
     image.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
     return image;
@@ -2155,7 +2278,11 @@ bool writeP8(const QImage &image, QDataStream &s)
 
     s << dds;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> palette = outImage.colorTable();
+#else
+    QVector<QRgb> palette = outImage.colorTable();
+#endif
     for (int i = 0; i < 256; ++i) {
         quint8 r = 0, g = 0, b = 0, a = 0xff;
         if (i < palette.size()) {
@@ -2191,6 +2318,7 @@ bool writeP8(const QImage &image, QDataStream &s)
     return true;
 }
 
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
 bool writeA16B16G16R16F(const QImage &outImage, QDataStream &s)
 {
     DDSHeader dds;
@@ -2312,6 +2440,7 @@ bool writeA32B32G32R32F(const QImage &outImage, QDataStream &s)
 
     return true;
 }
+#endif
 
 bool QDDSHandler::write(const QImage &outImage)
 {
@@ -2325,6 +2454,7 @@ bool QDDSHandler::write(const QImage &outImage)
     int format = m_format;
     if (format == FormatUnknown) {
         switch (outImage.format()) {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         case QImage::Format_RGBX16FPx4:
         case QImage::Format_RGBA16FPx4:
         case QImage::Format_RGBA16FPx4_Premultiplied:
@@ -2336,6 +2466,7 @@ bool QDDSHandler::write(const QImage &outImage)
         case QImage::Format_RGBA32FPx4_Premultiplied:
             format = FormatA32B32G32R32F;
             break;
+#endif
 
         case QImage::Format_Grayscale16:
         case QImage::Format_Grayscale8:
@@ -2369,6 +2500,7 @@ bool QDDSHandler::write(const QImage &outImage)
         return writeP8(outImage, s);
     }
 
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     if (format == FormatA16B16G16R16F) {
         return writeA16B16G16R16F(outImage, s);
     }
@@ -2376,6 +2508,7 @@ bool QDDSHandler::write(const QImage &outImage)
     if (format == FormatA32B32G32R32F) {
         return writeA32B32G32R32F(outImage, s);
     }
+#endif
 
     qWarning() << "Format" << formatName(format) << "is not supported";
     return false;
diff --git a/src/imageformats/exr.cpp b/src/imageformats/exr.cpp
index 187dd7e..b9a2a77 100644
--- a/src/imageformats/exr.cpp
+++ b/src/imageformats/exr.cpp
@@ -81,7 +81,10 @@
 #include <QImageIOPlugin>
 #include <QLocale>
 #include <QThread>
+
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
 #include <QTimeZone>
+#endif
 
 class K_IStream : public Imf::IStream
 {
@@ -216,7 +219,11 @@ bool EXRHandler::canRead() const
 static QImage::Format imageFormat(const Imf::RgbaInputFile &file)
 {
     auto isRgba = file.channels() & Imf::RgbaChannels::WRITE_A;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
     return (isRgba ? QImage::Format_RGBA16FPx4 : QImage::Format_RGBX16FPx4);
+#else
+    return (isRgba ? QImage::Format_RGBA64 : QImage::Format_RGBX64);
+#endif
 }
 
 /*!
@@ -278,7 +285,11 @@ static void readMetadata(const Imf::Header &header, QImage &image)
         }
         auto dateTime = QDateTime::fromString(QString::fromStdString(capDate->value()), QStringLiteral("yyyy:MM:dd HH:mm:ss"));
         if (dateTime.isValid()) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
             dateTime.setTimeZone(QTimeZone::fromSecondsAheadOfUtc(off));
+#else
+            dateTime.setOffsetFromUtc(off);
+#endif
             image.setText(QStringLiteral(META_KEY_CREATIONDATE), dateTime.toString(Qt::ISODate));
         }
     }
@@ -404,6 +415,7 @@ bool EXRHandler::read(QImage *outImage)
             file.readPixels(my, std::min(my + EXR_LINES_PER_BLOCK - 1, dw.max.y));
 
             for (n = 0; n < std::min(EXR_LINES_PER_BLOCK, height - y); ++n) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
                 auto scanLine = reinterpret_cast<qfloat16 *>(image.scanLine(y + n));
                 for (int x = 0; x < width; ++x) {
                     auto xcs = x * 4;
@@ -412,6 +424,15 @@ bool EXRHandler::read(QImage *outImage)
                     *(scanLine + xcs + 2) = qfloat16(float(pixels[n][x].b));
                     *(scanLine + xcs + 3) = qfloat16(isRgba ? std::clamp(float(pixels[n][x].a), 0.f, 1.f) : 1.f);
                 }
+#else
+                auto scanLine = reinterpret_cast<QRgba64 *>(image.scanLine(y + n));
+                for (int x = 0; x < width; ++x) {
+                    *(scanLine + x) = QRgba64::fromRgba64(quint16(qBound(0.f, float(pixels[n][x].r) * 65535.f + 0.5f, 65535.f)),
+                                                          quint16(qBound(0.f, float(pixels[n][x].g) * 65535.f + 0.5f, 65535.f)),
+                                                          quint16(qBound(0.f, float(pixels[n][x].b) * 65535.f + 0.5f, 65535.f)),
+                                                          isRgba ? quint16(qBound(0.f, float(pixels[n][x].a) * 65535.f + 0.5f, 65535.f)) : quint16(65535));
+                }
+#endif
             }
         }
 
@@ -598,12 +619,17 @@ bool EXRHandler::write(const QImage &image)
         pixels.resizeErase(EXR_LINES_PER_BLOCK, width);
 
         // convert the image and write into the stream
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
         auto convFormat = image.hasAlphaChannel() ? QImage::Format_RGBA16FPx4 : QImage::Format_RGBX16FPx4;
+#else
+        auto convFormat = image.hasAlphaChannel() ? QImage::Format_RGBA64 : QImage::Format_RGBX64;
+#endif
         ScanLineConverter slc(convFormat);
         slc.setDefaultSourceColorSpace(QColorSpace(QColorSpace::SRgb));
         slc.setTargetColorSpace(QColorSpace(QColorSpace::SRgbLinear));
         for (int y = 0, n = 0; y < height; y += n) {
             for (n = 0; n < std::min(EXR_LINES_PER_BLOCK, height - y); ++n) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
                 auto scanLine = reinterpret_cast<const qfloat16 *>(slc.convertedScanLine(image, y + n));
                 if (scanLine == nullptr) {
                     return false;
@@ -615,6 +641,18 @@ bool EXRHandler::write(const QImage &image)
                     pixels[n][x].b = float(*(scanLine + xcs + 2));
                     pixels[n][x].a = float(*(scanLine + xcs + 3));
                 }
+#else
+                auto scanLine = reinterpret_cast<const QRgba64 *>(slc.convertedScanLine(image, y + n));
+                if (scanLine == nullptr) {
+                    return false;
+                }
+                for (int x = 0; x < width; ++x) {
+                    pixels[n][x].r = float((scanLine + x)->red() / 65535.f);
+                    pixels[n][x].g = float((scanLine + x)->green() / 65535.f);
+                    pixels[n][x].b = float((scanLine + x)->blue() / 65535.f);
+                    pixels[n][x].a = float((scanLine + x)->alpha() / 65535.f);
+                }
+#endif
             }
             file.setFrameBuffer(&pixels[0][0] - qint64(y) * width, 1, width);
             file.writePixels(n);
diff --git a/src/imageformats/hdr.cpp b/src/imageformats/hdr.cpp
index 264d1ca..6ffdddc 100644
--- a/src/imageformats/hdr.cpp
+++ b/src/imageformats/hdr.cpp
@@ -161,7 +161,9 @@ public:
                                           QPointF(primaries.at(2), primaries.at(3)),
                                           QPointF(primaries.at(4), primaries.at(5)),
                                           QColorSpace::TransferFunction::Linear);
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
                     cs.setDescription(QStringLiteral("Embedded RGB"));
+#endif
                     if (cs.isValid())
                         h.m_colorSpace = cs;
                 }
@@ -228,6 +230,17 @@ private:
     Header m_header;
 };
 
+#if QT_VERSION < QT_VERSION_CHECK(6, 2, 0)
+static inline uchar ClipToByte(float value)
+{
+    if (value > 255.0f) {
+        return 255;
+    }
+    // else if (value < 0.0f) return 0;  // we know value is positive.
+    return uchar(value);
+}
+#endif
+
 // read an old style line from the hdr image file
 // if 'first' is true the first byte is already read
 static bool Read_Old_Line(uchar *image, int width, QDataStream &s)
@@ -284,6 +297,7 @@ void RGBE_To_QRgbLine(uchar *image, float_T *scanline, const Header& h)
             v = 1.0f / float(1 << -e);
         }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
         auto j4 = j * 4;
         auto vn = v / 255.0f;
         if (exposure > 0) {
@@ -294,17 +308,24 @@ void RGBE_To_QRgbLine(uchar *image, float_T *scanline, const Header& h)
         scanline[j4 + 1] = float_T(float(image[1]) * vn);
         scanline[j4 + 2] = float_T(float(image[2]) * vn);
         scanline[j4 + 3] = float_T(1.0f);
+#else
+        scanline[j] = qRgb(ClipToByte(float(image[0]) * v), ClipToByte(float(image[1]) * v), ClipToByte(float(image[2]) * v));
+#endif
         image += 4;
     }
 }
 
 QImage::Format imageFormat()
 {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
 #ifdef HDR_HALF_QUALITY
     return QImage::Format_RGBX16FPx4;
 #else
     return QImage::Format_RGBX32FPx4;
 #endif
+#else
+    return QImage::Format_RGB32;
+#endif
 }
 
 // Load the HDR image.
@@ -328,11 +349,15 @@ static bool LoadHDR(QDataStream &s, const Header& h, QImage &img)
     uchar *image = reinterpret_cast<uchar *>(lineArray.data());
 
     for (int cline = 0; cline < height; cline++) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
 #ifdef HDR_HALF_QUALITY
         auto scanline = reinterpret_cast<qfloat16 *>(img.scanLine(cline));
 #else
         auto scanline = reinterpret_cast<float *>(img.scanLine(cline));
 #endif
+#else
+        auto scanline = reinterpret_cast<QRgb *>(img.scanLine(cline));
+#endif
 
         // determine scanline type
         if ((width < MINELEN) || (MAXELEN < width)) {
@@ -475,7 +500,7 @@ QVariant HDRHandler::option(ImageOption option) const
         if (auto dev = device()) {
             auto&& h = d->header(dev);
             if (h.isValid()) {
-                v = QVariant::fromValue(h.transformation());
+                v = QVariant::fromValue(int(h.transformation()));
             }
         }
     }
diff --git a/src/imageformats/iff.cpp b/src/imageformats/iff.cpp
index 2c39d4f..a0d39ca 100644
--- a/src/imageformats/iff.cpp
+++ b/src/imageformats/iff.cpp
@@ -203,12 +203,14 @@ static void addMetadata(QImage &img, const IFOR_Chunk *form)
     if (!iccps.isEmpty()) {
         auto cs = iccps.first()->value();
         if (cs.isValid()) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
             auto iccns = IFFChunk::searchT<ICCNChunk>(form);
             if (!iccns.isEmpty()) {
                 auto desc = iccns.first()->value();
                 if (!desc.isEmpty())
                     cs.setDescription(desc);
             }
+#endif
             img.setColorSpace(cs);
         }
     }
@@ -248,13 +250,13 @@ static void addMetadata(QImage &img, const IFOR_Chunk *form)
 static QImage convertIPAL(const QImage& img, const IPALChunk *ipal)
 {
     if (img.format() != QImage::Format_Indexed8) {
-        qDebug(LOG_IFFPLUGIN) << "convertIPAL(): the image is not indexed!";
+        qCDebug(LOG_IFFPLUGIN) << "convertIPAL(): the image is not indexed!";
         return img;
     }
 
     auto tmp = img.convertToFormat(FORMAT_RGB_8BIT);
     if (tmp.isNull()) {
-        qCritical(LOG_IFFPLUGIN) << "convertIPAL(): error while converting the image!";
+        qCCritical(LOG_IFFPLUGIN) << "convertIPAL(): error while converting the image!";
         return img;
     }
 
@@ -413,7 +415,11 @@ bool IFFHandler::readMayaImage(QImage *image)
         painter.drawImage(tp, ti);
     }
 #if QT_VERSION < QT_VERSION_CHECK(6, 9, 0)
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
     img.mirror(false, true);
+#else
+    img = img.mirrored(false, true);
+#endif
 #else
     img.flip(Qt::Orientation::Vertical);
 #endif
@@ -485,7 +491,7 @@ QVariant IFFHandler::option(ImageOption option) const
     }
 
     if (option == QImageIOHandler::ImageTransformation) {
-        return QVariant::fromValue(form->transformation());
+        return QVariant::fromValue(int(form->transformation()));
     }
 
     return {};
diff --git a/src/imageformats/jp2.cpp b/src/imageformats/jp2.cpp
index d796845..b71da82 100644
--- a/src/imageformats/jp2.cpp
+++ b/src/imageformats/jp2.cpp
@@ -313,10 +313,14 @@ public:
         }
 
         auto f = img.format();
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         if (f == QImage::Format_RGBA32FPx4 || f == QImage::Format_RGBX32FPx4) {
             if (!jp2ToImage<quint32>(&img))
                 return {};
             alphaFix<float>(&img);
+#else
+        if (false) {
+#endif
         } else if (f == QImage::Format_RGBA64 || f == QImage::Format_RGBX64 || f == QImage::Format_Grayscale16) {
             if (!jp2ToImage<quint16>(&img))
                 return {};
@@ -344,6 +348,7 @@ public:
             return false;
         }
 
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
         // OpenJPEG uses a shadow copy @32-bit/channel so we need to do a check
         auto maxBytes = qint64(QImageReader::allocationLimit()) * 1024 * 1024;
         auto neededBytes = qint64(width) * height * nchannels * 4;
@@ -351,6 +356,7 @@ public:
             qCritical() << "Allocation limit set to" << (maxBytes / 1024 / 1024) << "MiB but" << (neededBytes / 1024 / 1024) << "MiB are needed!";
             return false;
         }
+#endif
 
         return true;
     }
@@ -410,9 +416,11 @@ public:
                         fmt = hasAlpha ? QImage::Format_RGBA8888 : QImage::Format_RGBX8888;
                     else if (prec == 16)
                         fmt = hasAlpha ? QImage::Format_RGBA64 : QImage::Format_RGBX64;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
 #ifdef JP2_ENABLE_HDR
                     else if (prec == 32) // not sure about this
                         fmt = hasAlpha ? QImage::Format_RGBA32FPx4 : QImage::Format_RGBX32FPx4;
+#endif
 #endif
                 }
             } else if (jp2cs == OPJ_CLRSPC_GRAY) {
@@ -534,6 +542,7 @@ public:
             cs = OPJ_CLRSPC_GRAY;
             convFormat = QImage::Format_Grayscale16;
             break;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         case QImage::Format_RGBX16FPx4:
         case QImage::Format_RGBX32FPx4:
             isFloat = true;
@@ -544,6 +553,7 @@ public:
             break;
 #else
             Q_FALLTHROUGH();
+#endif
 #endif
         case QImage::Format_RGBX64:
         case QImage::Format_RGB30:
@@ -552,6 +562,7 @@ public:
             convFormat = QImage::Format_RGBX64;
             break;
 
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         case QImage::Format_RGBA16FPx4:
         case QImage::Format_RGBA16FPx4_Premultiplied:
         case QImage::Format_RGBA32FPx4:
@@ -564,6 +575,7 @@ public:
             break;
 #else
             Q_FALLTHROUGH();
+#endif
 #endif
         case QImage::Format_RGBA64:
         case QImage::Format_RGBA64_Premultiplied:
diff --git a/src/imageformats/jxl.cpp b/src/imageformats/jxl.cpp
index 02a87f6..e28558f 100644
--- a/src/imageformats/jxl.cpp
+++ b/src/imageformats/jxl.cpp
@@ -8,6 +8,7 @@
 
 #include <QThread>
 #include <QtGlobal>
+#include <QFloat16>
 
 #include "jxl_p.h"
 #include "microexif_p.h"
@@ -63,7 +64,7 @@ typedef enum {JXL_ENC_SUCCESS, JXL_ENC_ERROR, JXL_ENC_NEED_MORE_OUTPUT, JXL_ENC_
 #include <string.h>
 
 // Avoid rotation on buggy Qts (see also https://bugreports.qt.io/browse/QTBUG-126575)
-#if QT_VERSION >= QT_VERSION_CHECK(6, 7, 3)
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 5, 7) && QT_VERSION < QT_VERSION_CHECK(6, 6, 0)) || (QT_VERSION >= QT_VERSION_CHECK(6, 7, 3))
 #ifndef JXL_QT_AUTOTRANSFORM
 #define JXL_QT_AUTOTRANSFORM
 #endif
@@ -73,7 +74,7 @@ typedef enum {JXL_ENC_SUCCESS, JXL_ENC_ERROR, JXL_ENC_NEED_MORE_OUTPUT, JXL_ENC_
 // Define JXL_HDR_PRESERVATION_DISABLED to disable HDR preservation
 // (HDR images are saved as UINT16).
 // #define JXL_HDR_PRESERVATION_DISABLED
-#if JPEGXL_NUMERIC_VERSION >= JPEGXL_COMPUTE_NUMERIC_VERSION(0, 9, 0)
+#if JPEGXL_NUMERIC_VERSION >= JPEGXL_COMPUTE_NUMERIC_VERSION(0, 9, 0) || (QT_VERSION < QT_VERSION_CHECK(6, 2, 0))
 #define JXL_HDR_PRESERVATION_DISABLED
 #endif
 #endif
@@ -337,6 +338,7 @@ bool QJpegXLHandler::countALLFrames()
             m_input_pixel_format.num_channels = 1;
             m_input_pixel_format.data_type = JXL_TYPE_UINT16;
             m_input_image_format = m_target_image_format = QImage::Format_Grayscale16;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         } else if (m_basicinfo.bits_per_sample > 16 && is_fp) {
             m_input_pixel_format.data_type = JXL_TYPE_FLOAT;
             m_input_image_format = QImage::Format_RGBA32FPx4;
@@ -351,6 +353,15 @@ bool QJpegXLHandler::countALLFrames()
                 m_target_image_format = is_fp ? QImage::Format_RGBA16FPx4 : QImage::Format_RGBA64;
             else
                 m_target_image_format = is_fp ? QImage::Format_RGBX16FPx4 : QImage::Format_RGBX64;
+#else
+            Q_ASSERT(!is_fp);
+            m_input_pixel_format.data_type = JXL_TYPE_UINT16;
+            m_input_image_format = QImage::Format_RGBA64;
+            if (loadalpha)
+                m_target_image_format = QImage::Format_RGBA64;
+            else
+                m_target_image_format = QImage::Format_RGBX64;
+#endif
         }
     } else { // 8bit depth
         m_input_pixel_format.data_type = JXL_TYPE_UINT8;
@@ -1179,6 +1190,7 @@ bool QJpegXLHandler::write(const QImage &image)
         bool is_gray = false;
         // depth detection
         switch (image.format()) {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         case QImage::Format_RGBX32FPx4:
         case QImage::Format_RGBA32FPx4:
         case QImage::Format_RGBA32FPx4_Premultiplied:
@@ -1194,6 +1206,7 @@ bool QJpegXLHandler::write(const QImage &image)
             save_depth = 16;
             save_fp = true;
             break;
+#endif
 #endif
         case QImage::Format_BGR30:
         case QImage::Format_A2BGR30_Premultiplied:
@@ -1254,6 +1267,7 @@ bool QJpegXLHandler::write(const QImage &image)
             output_info.bits_per_sample = 8;
             tmpformat = QImage::Format_Grayscale8;
             pixel_format.num_channels = 1;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         } else if (save_depth > 16) { // 32bit depth rgb
             pixel_format.data_type = JXL_TYPE_FLOAT;
             output_info.exponent_bits_per_sample = 8;
@@ -1290,6 +1304,27 @@ bool QJpegXLHandler::write(const QImage &image)
                 output_info.alpha_bits = 0;
                 output_info.num_extra_channels = 0;
             }
+#else
+        } else if (save_depth > 8) { // 16bit depth rgb
+            Q_ASSERT(!save_fp);
+            pixel_format.data_type = JXL_TYPE_UINT16;
+            output_info.exponent_bits_per_sample = 0;
+            output_info.num_color_channels = 3;
+            output_info.bits_per_sample = 16;
+
+            if (image.hasAlphaChannel()) {
+                tmpformat = QImage::Format_RGBA64;
+                pixel_format.num_channels = 4;
+                output_info.alpha_bits = 16;
+                output_info.alpha_exponent_bits = 0;
+                output_info.num_extra_channels = 1;
+            } else {
+                tmpformat = QImage::Format_RGBX64;
+                pixel_format.num_channels = 3;
+                output_info.alpha_bits = 0;
+                output_info.num_extra_channels = 0;
+            }
+#endif
         } else { // 8bit depth rgb
             pixel_format.data_type = JXL_TYPE_UINT8;
             output_info.num_color_channels = 3;
@@ -1554,6 +1589,7 @@ bool QJpegXLHandler::write(const QImage &image)
         }
 
         size_t buffer_size;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         if (tmpimage.format() == QImage::Format_RGBX32FPx4) { // pack 32-bit depth RGBX -> RGB
             buffer_size = 12 * size_t(tmpimage.width()) * size_t(tmpimage.height());
 
@@ -1582,6 +1618,9 @@ bool QJpegXLHandler::write(const QImage &image)
             status = JxlEncoderAddImageFrame(encoder_options, &pixel_format, packed_pixels32, buffer_size);
             free(packed_pixels32);
         } else if (tmpimage.format() == QImage::Format_RGBX16FPx4 || tmpimage.format() == QImage::Format_RGBX64) {
+#else
+        if (tmpimage.format() == QImage::Format_RGBX64) {
+#endif
             // pack 16-bit depth RGBX -> RGB
             buffer_size = 6 * size_t(tmpimage.width()) * size_t(tmpimage.height());
 
diff --git a/src/imageformats/jxl_p.h b/src/imageformats/jxl_p.h
index c062584..ef1fac6 100644
--- a/src/imageformats/jxl_p.h
+++ b/src/imageformats/jxl_p.h
@@ -17,6 +17,10 @@
 #include <QList>
 #include <QVariant>
 
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
+
 #include <jxl/decode.h>
 
 class QJpegXLHandler : public QImageIOHandler
@@ -74,7 +78,11 @@ private:
     void *m_runner;
     JxlBasicInfo m_basicinfo;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<int> m_framedelays;
+#else
+    QVector<int> m_framedelays;
+#endif
     int m_next_image_delay;
 
     QImage m_current_image;
diff --git a/src/imageformats/jxr.cpp b/src/imageformats/jxr.cpp
index d7b90be..8c6d118 100644
--- a/src/imageformats/jxr.cpp
+++ b/src/imageformats/jxr.cpp
@@ -46,6 +46,9 @@ Q_LOGGING_CATEGORY(LOG_JXRPLUGIN, "kf.imageformats.plugins.jxr", QtWarningMsg)
  * NOTE: Float images have values greater than 1 so they need an additional in place conversion.
  */
 // #define JXR_DENY_FLOAT_IMAGE
+#if QT_VERSION < QT_VERSION_CHECK(6, 2, 0)
+#define JXR_DENY_FLOAT_IMAGE
+#endif
 
 /*!
  * Remove the neeeds of additional memory by disabling the conversion between
@@ -649,8 +652,8 @@ public:
             if (cs.isValid() && cs.transferFunction() != QColorSpace::TransferFunction::Linear) {
                 qi = qi.convertedToColorSpace(QColorSpace(QColorSpace::SRgbLinear));
             }
-        }
 #endif // JXR_DENY_FLOAT_IMAGE
+        }
 
         return qi;
     }
@@ -1015,11 +1018,13 @@ bool JXRHandler::read(QImage *outImage)
         } else { // additional buffer needed
             qint64 convStrideSize = (img.width() * d->pDecoder->WMP.wmiI.cBitsPerUnit + 7) / 8;
             qint64 buffSize = convStrideSize * img.height();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
             qint64 limit = QImageReader::allocationLimit();
             if (limit && (buffSize + img.sizeInBytes()) > limit * 1024 * 1024) {
                 qCWarning(LOG_JXRPLUGIN) << "JXRHandler::read() unable to covert due to allocation limit set:" << limit << "MiB";
                 return false;
             }
+#endif
             QVector<quint8> ba(buffSize);
             if (auto err = pConverter->Copy(pConverter, &rect, ba.data(), convStrideSize)) {
                 PKFormatConverter_Release(&pConverter);
@@ -1095,15 +1100,27 @@ bool JXRHandler::write(const QImage &image)
 #ifndef JXR_DISABLE_BGRA_HACK
     if (IsEqualGUID(jxlfmt, GUID_PKPixelFormat32bppRGB)) {
         jxlfmt = GUID_PKPixelFormat32bppBGR;
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+        qi = qi.rgbSwapped();
+#else
         qi.rgbSwap();
+#endif
     }
     if (IsEqualGUID(jxlfmt, GUID_PKPixelFormat32bppRGBA)) {
         jxlfmt = GUID_PKPixelFormat32bppBGRA;
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+        qi = qi.rgbSwapped();
+#else
         qi.rgbSwap();
+#endif
     }
     if (IsEqualGUID(jxlfmt, GUID_PKPixelFormat32bppPRGBA)) {
         jxlfmt = GUID_PKPixelFormat32bppPBGRA;
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+        qi = qi.rgbSwapped();
+#else
         qi.rgbSwap();
+#endif
     }
 #endif
 
diff --git a/src/imageformats/microexif.cpp b/src/imageformats/microexif.cpp
index 876ea47..eebb93b 100644
--- a/src/imageformats/microexif.cpp
+++ b/src/imageformats/microexif.cpp
@@ -12,7 +12,9 @@
 #include <QCoreApplication>
 #include <QDataStream>
 #include <QHash>
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
 #include <QStringDecoder>
+#endif
 #include <QTimeZone>
 
 // TIFF 6 specs
@@ -491,14 +493,27 @@ static QByteArray readBytes(QDataStream &ds, quint32 count, bool asciiz)
     }
     char c;
     for (quint32 i = 0; i < count; ++i) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         ds >> c;
+#else
+        ds >> reinterpret_cast<qint8&>(c);
+#endif
         l.append(c);
     }
     if (asciiz && l.at(l.size() - 1) == 0) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
         l.removeLast();
+#else
+        if(!l.isEmpty())
+            l.remove(l.size() - 1, 1);
+#endif
     }
     for (auto n = count; n < 4; ++n) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         ds >> c;
+#else
+        ds >> reinterpret_cast<qint8&>(c);
+#endif
     }
     return l;
 }
@@ -562,6 +577,7 @@ static bool readIfd(QDataStream &ds, MicroExif::Tags &tags, quint32 pos = 0, con
         if (dataType == EXIF_TAG_DATATYPE(ExifTagType::Ascii) || dataType == EXIF_TAG_DATATYPE(ExifTagType::Utf8)) {
             auto l = readBytes(ds, count, true);
             if (!l.isEmpty()) {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
                 // It seems that converting to Latin 1 never detects errors so, using UTF-8.
                 // Note that if the dataType is ASCII, by EXIF specification, it must use only the
                 // first 128 values ​​so the UTF-8 conversion is correct.
@@ -570,6 +586,10 @@ static bool readIfd(QDataStream &ds, MicroExif::Tags &tags, quint32 pos = 0, con
                 auto ut8 = QString(dec(l));
                 // If there are errors in the conversion to UTF-8, then I try with latin1 (extended ASCII)
                 tags.insert(tagId, dec.hasError() ? QString::fromLatin1(l) : ut8);
+#else
+                auto ut8 = QString::fromUtf8(l);
+                tags.insert(tagId, ut8.isEmpty() ? QString::fromLatin1(l) : ut8);
+#endif
             }
         } else if (dataType == EXIF_TAG_DATATYPE(ExifTagType::Undefined)) {
             auto l = readBytes(ds, count, false);
@@ -883,7 +903,11 @@ QDateTime MicroExif::dateTime() const
     auto dt = QDateTime::fromString(tiffString(TIFF_DATETIME), QStringLiteral("yyyy:MM:dd HH:mm:ss"));
     auto ofTag = exifString(EXIF_OFFSETTIME);
     if (dt.isValid() && !ofTag.isEmpty())
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
         dt.setTimeZone(QTimeZone::fromSecondsAheadOfUtc(timeOffset(ofTag) * 60));
+#else
+        dt.setTimeZone(QTimeZone(static_cast<int>(timeOffset(ofTag) * 60)));
+#endif
     return(dt);
 }
 
@@ -903,7 +927,11 @@ QDateTime MicroExif::dateTimeOriginal() const
     auto dt = QDateTime::fromString(exifString(EXIF_DATETIMEORIGINAL), QStringLiteral("yyyy:MM:dd HH:mm:ss"));
     auto ofTag = exifString(EXIF_OFFSETTIMEORIGINAL);
     if (dt.isValid() && !ofTag.isEmpty())
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
         dt.setTimeZone(QTimeZone::fromSecondsAheadOfUtc(timeOffset(ofTag) * 60));
+#else
+        dt.setTimeZone(QTimeZone(static_cast<int>(timeOffset(ofTag) * 60)));
+#endif
     return(dt);
 }
 
@@ -923,7 +951,11 @@ QDateTime MicroExif::dateTimeDigitized() const
     auto dt = QDateTime::fromString(exifString(EXIF_DATETIMEDIGITIZED), QStringLiteral("yyyy:MM:dd HH:mm:ss"));
     auto ofTag = exifString(EXIF_OFFSETTIMEDIGITIZED);
     if (dt.isValid() && !ofTag.isEmpty())
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
         dt.setTimeZone(QTimeZone::fromSecondsAheadOfUtc(timeOffset(ofTag) * 60));
+#else
+        dt.setTimeZone(QTimeZone(static_cast<int>(timeOffset(ofTag) * 60)));
+#endif
     return(dt);
 }
 
diff --git a/src/imageformats/pcx.cpp b/src/imageformats/pcx.cpp
index 5a9d8de..084d474 100644
--- a/src/imageformats/pcx.cpp
+++ b/src/imageformats/pcx.cpp
@@ -774,10 +774,10 @@ static bool writeImage24(const QImage &image, QDataStream &s, PCXHEADER &header)
         return false;
     }
 
-#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     auto cs = image.colorSpace();
     auto tcs = QColorSpace();
     auto tfmt = image.format();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     if (cs.isValid() && cs.colorModel() == QColorSpace::ColorModel::Cmyk && tfmt == QImage::Format_CMYK8888) {
         tcs = QColorSpace(QColorSpace::SRgb);
         tfmt = QImage::Format_RGB32;
diff --git a/src/imageformats/pfm.cpp b/src/imageformats/pfm.cpp
index 68ace1e..a8e709f 100644
--- a/src/imageformats/pfm.cpp
+++ b/src/imageformats/pfm.cpp
@@ -131,7 +131,11 @@ public:
     QImage::Format format() const
     {
         if (isValid()) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
             return m_half ? QImage::Format_RGBX16FPx4 : QImage::Format_RGBX32FPx4;
+#else
+            return QImage::Format_RGB32;
+#endif
         }
         return QImage::Format_Invalid;
     }
@@ -233,6 +237,7 @@ template<class T>
 bool readScanLine(qint32 y, QDataStream &s, QImage &img, const PFMHeader &header)
 {
     auto bw = header.isBlackAndWhite();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
     auto line = reinterpret_cast<T *>(img.scanLine(header.isPhotoshop() ? y : img.height() - y - 1));
     for (auto x = 0, n = img.width() * 4; x < n; x += 4) {
         line[x + 3] = T(1);
@@ -244,6 +249,23 @@ bool readScanLine(qint32 y, QDataStream &s, QImage &img, const PFMHeader &header
             s >> line[x + 1];
             s >> line[x + 2];
         }
+#else
+    auto line = reinterpret_cast<QRgb *>(img.scanLine(header.isPhotoshop() ? y : img.height() - y - 1));
+    for (auto x = 0, n = img.width() * 4; x < n; x += 4) {
+        int r, g, b;
+        T f;
+        s >> f;
+        r = qBound(int(0), int(f * 255.0f), int(255));
+        if (bw) {
+            g = b = r;
+        } else {
+            s >> f;
+            g = qBound(int(0), int(f * 255.0f), int(255));
+            s >> f;
+            b = qBound(int(0), int(f * 255.0f), int(255));
+        }
+        line[x] = qRgb(r, g, b);
+#endif
         if (s.status() != QDataStream::Ok) {
             return false;
         }
@@ -296,9 +318,11 @@ bool PFMHandler::supportsOption(ImageOption option) const
     if (option == QImageIOHandler::ImageFormat) {
         return true;
     }
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
     if (option == QImageIOHandler::Endianness) {
         return true;
     }
+#endif
     return false;
 }
 
@@ -328,6 +352,7 @@ QVariant PFMHandler::option(ImageOption option) const
         }
     }
 
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
     if (option == QImageIOHandler::Endianness) {
         auto&& h = d->m_header;
         if (h.isValid()) {
@@ -338,6 +363,7 @@ QVariant PFMHandler::option(ImageOption option) const
             }
         }
     }
+#endif
 
     return v;
 }
diff --git a/src/imageformats/pic.cpp b/src/imageformats/pic.cpp
index 3ae1d7d..eef73a9 100644
--- a/src/imageformats/pic.cpp
+++ b/src/imageformats/pic.cpp
@@ -267,10 +267,10 @@ bool SoftimagePICHandler::read(QImage *image)
 bool SoftimagePICHandler::write(const QImage &image)
 {
     bool alpha = image.hasAlphaChannel();
-#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     auto cs = image.colorSpace();
     auto tfmt = image.format();
     auto tcs = QColorSpace();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     if (cs.isValid() && cs.colorModel() == QColorSpace::ColorModel::Cmyk && tfmt == QImage::Format_CMYK8888) {
         tcs = QColorSpace(QColorSpace::SRgb);
         tfmt = QImage::Format_RGB32;
diff --git a/src/imageformats/psd.cpp b/src/imageformats/psd.cpp
index 444b9d8..c71d138 100644
--- a/src/imageformats/psd.cpp
+++ b/src/imageformats/psd.cpp
@@ -38,6 +38,10 @@
 #include <QImage>
 #include <QColorSpace>
 
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
+
 #include <cmath>
 #include <cstring>
 
@@ -163,7 +167,11 @@ struct PSDDuotoneOptions {
  */
 struct PSDColorModeDataSection {
     PSDDuotoneOptions duotone;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> palette;
+#else
+    QVector<QRgb> palette;
+#endif
 };
 
 using PSDImageResourceSection = QHash<quint16, PSDImageResourceBlock>;
@@ -494,7 +502,11 @@ PSDColorModeDataSection readColorModeDataSection(QDataStream &s, bool *ok = null
             *ok = false;
     } else { // read the palette (768 bytes)
         auto &&palette = cms.palette;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         QList<quint8> vect(size);
+#else
+        QVector<quint8> vect(size);
+#endif
         for (auto &&v : vect)
             s >> v;
         for (qsizetype i = 0, n = vect.size()/3; i < n; ++i)
@@ -737,9 +749,13 @@ static QImage::Format imageFormat(const PSDHeader &header, bool alpha)
     auto format = QImage::Format_Invalid;
     switch(header.color_mode) {
     case CM_RGB:
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         if (header.depth == 32) {
             format = header.channel_count < 4 || !alpha ? QImage::Format_RGBX32FPx4 : QImage::Format_RGBA32FPx4_Premultiplied;
         } else if (header.depth == 16) {
+#else
+        if (header.depth == 16 || header.depth == 32) {
+#endif
             format = header.channel_count < 4 || !alpha ? QImage::Format_RGBX64 : QImage::Format_RGBA64_Premultiplied;
         } else {
             format = header.channel_count < 4 || !alpha ? QImage::Format_RGB888 : QImage::Format_RGBA8888_Premultiplied;
@@ -1287,7 +1303,11 @@ bool PSDHandler::read(QImage *image)
         return false;
     }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<quint32> strides(header.height * header.channel_count, raw_count);
+#else
+    QVector<quint32> strides(header.height * header.channel_count, raw_count);
+#endif
     // Read the compressed stride sizes
     if (compression) {
         for (auto &&v : strides) {
@@ -1302,7 +1322,11 @@ bool PSDHandler::read(QImage *image)
     }
     // calculate the absolute file positions of each stride (required when a colorspace conversion should be done)
     auto device = stream.device();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<quint64> stridePositions(strides.size());
+#else
+    QVector<quint64> stridePositions(strides.size());
+#endif
     if (!stridePositions.isEmpty()) {
         stridePositions[0] = device->pos();
     }
@@ -1357,7 +1381,11 @@ bool PSDHandler::read(QImage *image)
                 } else if (header.depth == 16) {
                     planarToChunchy<quint16>(scanLine, rawStride.data(), header.width, c, header.channel_count);
                 } else if (header.depth == 32) {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
                     planarToChunchy<float>(scanLine, rawStride.data(), header.width, c, header.channel_count);
+#else
+                    planarToChunchyFloatToUInt16<float>(scanLine, rawStride.data(), header.width, c, header.channel_count);
+#endif
                 }
             }
 
@@ -1382,7 +1410,11 @@ bool PSDHandler::read(QImage *image)
                     else if (header.depth == 16)
                         premulConversion<quint16>(scanLine, header.width, 3, header.channel_count, PremulConversion::PS2P);
                     else if (header.depth == 32)
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
                         premulConversion<float>(scanLine, header.width, 3, header.channel_count, PremulConversion::PS2P);
+#else
+                        premulConversion<quint16>(scanLine, header.width, 3, header.channel_count, PremulConversion::PS2P);
+#endif
                 }
             }
 
@@ -1419,7 +1451,11 @@ bool PSDHandler::read(QImage *image)
                 else if (header.depth == 16)
                     rawChannelsCopy<quint16>(img.scanLine(y), imgChannels, psdScanline.data(), header.channel_count, header.width);
                 else if (header.depth == 32)
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
                     rawChannelsCopy<float>(img.scanLine(y), imgChannels, psdScanline.data(), header.channel_count, header.width);
+#else
+                    rawChannelsCopy<quint16>(img.scanLine(y), imgChannels, psdScanline.data(), header.channel_count, header.width);
+#endif
             }
         }
     } else {
@@ -1450,7 +1486,11 @@ bool PSDHandler::read(QImage *image)
                         planarToChunchy<quint16>(scanLine, rawStride.data(), header.width, c, imgChannels);
                 } else if (header.depth == 32 && header.color_mode == CM_RGB) {
                     // 32-bits float images: RGB/RGBA
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
                     planarToChunchy<float>(scanLine, rawStride.data(), header.width, c, imgChannels);
+#else
+                    planarToChunchyFloatToUInt16<float>(scanLine, rawStride.data(), header.width, c, imgChannels);
+#endif
                 } else if (header.depth == 32 && header.color_mode == CM_GRAYSCALE) {
                     // 32-bits float images: Grayscale (coverted to equivalent integer 16-bits)
                     planarToChunchyFloatToUInt16<float>(scanLine, rawStride.data(), header.width, c, imgChannels);
diff --git a/src/imageformats/pxr.cpp b/src/imageformats/pxr.cpp
index 668c7d2..6a80d8f 100644
--- a/src/imageformats/pxr.cpp
+++ b/src/imageformats/pxr.cpp
@@ -197,7 +197,7 @@ bool PXRHandler::read(QImage *image)
         return false;
     }
 
-    auto size = std::min(img.bytesPerLine(), header.strideSize());
+    auto size = std::min<qint64>(img.bytesPerLine(), header.strideSize());
     for (auto y = 0, h = img.height(); y < h; ++y) {
         auto line = reinterpret_cast<char*>(img.scanLine(y));
         if (d->read(line, size) != size) {
diff --git a/src/imageformats/ras.cpp b/src/imageformats/ras.cpp
index ea2afea..698c555 100644
--- a/src/imageformats/ras.cpp
+++ b/src/imageformats/ras.cpp
@@ -15,6 +15,10 @@
 #include <QDebug>
 #include <QImage>
 
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
+
 /* *** RAS_MAX_IMAGE_WIDTH and RAS_MAX_IMAGE_HEIGHT ***
  * The maximum size in pixel allowed by the plugin.
  */
@@ -234,14 +238,22 @@ static bool LoadRAS(QDataStream &s, const RasHeader &ras, QImage &img)
         if (ras.ColorMapLength > 768) {
             return false;
         }
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         QList<quint8> palette(ras.ColorMapLength);
+#else
+        QVector<quint8> palette(ras.ColorMapLength);
+#endif
         for (quint32 i = 0; i < ras.ColorMapLength; ++i) {
             s >> palette[i];
             if (s.status() != QDataStream::Ok) {
                 return false;
             }
         }
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         QList<QRgb> colorTable;
+#else
+        QVector<QRgb> colorTable;
+#endif
         for (quint32 i = 0, n = ras.ColorMapLength / 3; i < n; ++i) {
             colorTable << qRgb(palette.at(i), palette.at(i + n), palette.at(i + 2 * n));
         }
@@ -252,7 +264,7 @@ static bool LoadRAS(QDataStream &s, const RasHeader &ras, QImage &img)
     }
 
     LineDecoder dec(s.device(), ras);
-    auto bytesPerLine = std::min(img.bytesPerLine(), qsizetype(rasLineSize));
+    auto bytesPerLine = std::min(qsizetype(img.bytesPerLine()), qsizetype(rasLineSize));
     for (quint32 y = 0; y < ras.Height; ++y) {
         auto rasLine = dec.readLine(rasLineSize);
         if (rasLine.size() != rasLineSize) {
diff --git a/src/imageformats/rgb.cpp b/src/imageformats/rgb.cpp
index 2c409f6..ffb609d 100644
--- a/src/imageformats/rgb.cpp
+++ b/src/imageformats/rgb.cpp
@@ -31,7 +31,15 @@
 #include <QList>
 #include <QMap>
 
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
+
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 class RLEData : public QList<uchar>
+#else
+class RLEData : public QVector<uchar>
+#endif
 {
 public:
     RLEData()
@@ -64,7 +72,11 @@ public:
     {
     }
     uint insert(const uchar *d, uint l);
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<const RLEData *> vector();
+#else
+    QVector<const RLEData *> vector();
+#endif
     void setBaseOffset(uint o)
     {
         _offset = o;
@@ -123,7 +135,11 @@ private:
     QByteArray _data;
     QByteArray::Iterator _pos;
     RLEMap _rlemap;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<const RLEData *> _rlevector;
+#else
+    QVector<const RLEData *> _rlevector;
+#endif
     uint _numrows;
 
     bool readData(QImage &);
@@ -394,9 +410,17 @@ uint RLEMap::insert(const uchar *d, uint l)
     return QMap<RLEData, uint>::insert(data, _counter++).value();
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<const RLEData *> RLEMap::vector()
+#else
+QVector<const RLEData *> RLEMap::vector()
+#endif
 {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<const RLEData *> v(size());
+#else
+    QVector<const RLEData *> v(size());
+#endif
     for (Iterator it = begin(); it != end(); ++it) {
         v.replace(it.value(), &it.key());
     }
@@ -759,10 +783,10 @@ bool SGIImagePrivate::writeImage(const QImage &image)
         _dim = 3, _zsize++;
     }
 
-#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     auto cs = image.colorSpace();
     auto tcs = QColorSpace();
     auto tfmt = image.format();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     if (cs.isValid() && cs.colorModel() == QColorSpace::ColorModel::Cmyk && tfmt == QImage::Format_CMYK8888) {
         tcs = QColorSpace(QColorSpace::SRgb);
         tfmt = QImage::Format_RGB32;
diff --git a/src/imageformats/tga.cpp b/src/imageformats/tga.cpp
index e386ab3..32e7e9c 100644
--- a/src/imageformats/tga.cpp
+++ b/src/imageformats/tga.cpp
@@ -31,6 +31,9 @@
 #include <QDateTime>
 #include <QImage>
 #include <QLoggingCategory>
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
 
 typedef quint32 uint;
 typedef quint16 ushort;
@@ -609,7 +612,11 @@ static bool LoadTGA(QIODevice *dev, const TgaHeader &tga, QImage &img)
 
     // Read palette.
     if (info.pal) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         QList<QRgb> colorTable;
+#else
+        QVector<QRgb> colorTable;
+#endif
 #if QT_VERSION < QT_VERSION_CHECK(6, 8, 0)
         colorTable.resize(tga.colormap_length);
 #else
@@ -988,9 +995,9 @@ bool TGAHandler::writeRGBA(const QImage &image)
 {
     auto format = image.format();
     const bool hasAlpha = image.hasAlphaChannel();
-#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     auto cs = image.colorSpace();
     auto tcs = QColorSpace();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     if (cs.isValid() && cs.colorModel() == QColorSpace::ColorModel::Cmyk && image.format() == QImage::Format_CMYK8888) {
         format = QImage::Format_RGB32;
         tcs = QColorSpace(QColorSpace::SRgb);
diff --git a/src/imageformats/util_p.h b/src/imageformats/util_p.h
index 239a020..14bb8a4 100644
--- a/src/imageformats/util_p.h
+++ b/src/imageformats/util_p.h
@@ -14,7 +14,10 @@
 #include <limits>
 
 #include <QImage>
+
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 #include <QImageIOHandler>
+#endif
 
 // Default maximum width and height for the large image plugins.
 #ifndef KIF_LARGE_IMAGE_PIXEL_LIMIT
@@ -58,9 +61,13 @@ static const int kMaxQVectorSize = std::numeric_limits<int>::max() - 32;
 inline QImage imageAlloc(const QSize &size, const QImage::Format &format)
 {
     QImage img;
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+    img = QImage(size, format);
+#else
     if (!QImageIOHandler::allocateImage(size, format, &img)) {
         img = QImage(); // paranoia
     }
+#endif
     return img;
 }
 
diff --git a/src/imageformats/xcf.cpp b/src/imageformats/xcf.cpp
index 1c1df25..fbe563a 100644
--- a/src/imageformats/xcf.cpp
+++ b/src/imageformats/xcf.cpp
@@ -13,17 +13,28 @@
 #include <QDebug>
 #include <QIODevice>
 #include <QImage>
-#include <QImageReader>
 #include <QList>
 #include <QLoggingCategory>
 #include <QPainter>
 #include <QStack>
 #include <QtEndian>
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
+#include <QImageReader>
+#endif
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
+
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#define XCF_QT5_SUPPORT
+#endif
 
 #ifndef XCF_QT5_SUPPORT
 // Float images are not supported by Qt 5 and can be disabled in QT 6 to reduce memory usage.
 // Unfortunately enabling/disabling this define results in slightly different images, so leave the default if possible.
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
 #define USE_FLOAT_IMAGES // default uncommented
+#endif
 
 // Let's set a "reasonable" maximum size
 #ifndef XCF_MAX_IMAGE_WIDTH
@@ -114,7 +125,11 @@ struct RandomTable {
  * parallel processing on a tile-by-tile basis. Here, though,
  * we just read them in en-masse and store them in a matrix.
  */
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 typedef QList<QList<QImage>> Tiles;
+#else
+typedef QVector<QVector<QImage>> Tiles;
+#endif
 
 class XCFImageFormat
 {
@@ -496,7 +511,11 @@ public:
         qint32 tattoo; //!< (unique identifier?)
         quint32 unit; //!< Units of The GIMP (inch, mm, pica, etc...)
         qint32 num_colors = 0; //!< number of colors in an indexed image
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         QList<QRgb> palette; //!< indexed image color palette
+#else
+        QVector<QRgb> palette; //!< indexed image color palette
+#endif
 
         int num_layers; //!< number of layers
         Layer layer; //!< most recently read layer
@@ -549,7 +568,11 @@ private:
     //! This table is used as a shared grayscale ramp to be set on grayscale
     //! images. This is because Qt does not differentiate between indexed and
     //! grayscale images.
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     static QList<QRgb> grayTable;
+#else
+    static QVector<QRgb> grayTable;
+#endif
 
     //! This table provides the add_pixel saturation values (i.e. 250 + 250 = 255).
     // static int add_lut[256][256]; - this is so lame waste of 256k of memory
@@ -650,7 +673,11 @@ bool XCFImageFormat::random_table_initialized;
 
 const RandomTable XCFImageFormat::randomTable{};
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> XCFImageFormat::grayTable;
+#else
+QVector<QRgb> XCFImageFormat::grayTable;
+#endif
 
 bool XCFImageFormat::modeAffectsSourceAlpha(const quint32 type)
 {
@@ -966,7 +993,11 @@ bool XCFImageFormat::loadImageProperties(QDataStream &xcf_io, XCFImage &xcf_imag
         case PROP_PARASITES:
             while (!property.atEnd()) {
                 char *tag;
+#if QT_VERSION < QT_VERSION_CHECK(6, 7, 0)
+                quint32 size;
+#else
                 qint64 size;
+#endif
 
                 property.readBytes(tag, size);
 
@@ -999,7 +1030,11 @@ bool XCFImageFormat::loadImageProperties(QDataStream &xcf_io, XCFImage &xcf_imag
                 return false;
             }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
             xcf_image.palette = QList<QRgb>();
+#else
+            xcf_image.palette = QVector<QRgb>();
+#endif
             xcf_image.palette.reserve(xcf_image.num_colors);
 
             for (int i = 0; i < xcf_image.num_colors; i++) {
@@ -1388,11 +1423,13 @@ bool XCFImageFormat::composeTiles(XCFImage &xcf_image)
     // tiles of 64x64 pixels. The required memory to build the image is at least doubled because tiles are loaded
     // and then the final image is created by copying the tiles inside it.
     // NOTE: on Windows to open a 10GiB image the plugin uses 28GiB of RAM
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     qint64 channels = 1 + (layer.type == RGB_GIMAGE ? 2 : 0) + (layer.type == RGBA_GIMAGE ? 3 : 0);
     if (qint64(layer.width) * qint64(layer.height) * channels * 2ll / 1024ll / 1024ll > QImageReader::allocationLimit()) {
         qCDebug(XCFPLUGIN) << "Rejecting image as it exceeds the current allocation limit of" << QImageReader::allocationLimit() << "megabytes";
         return false;
     }
+#endif
 #endif
 
     layer.image_tiles.resize(layer.nrows);
@@ -2032,7 +2069,11 @@ bool XCFImageFormat::loadLevel(QDataStream &xcf_io, Layer &layer, qint32 bpp, co
 
     const uint blockSize = TILE_WIDTH * TILE_HEIGHT * bpp * 1.5;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<uchar> buffer;
+#else
+    QVector<uchar> buffer;
+#endif
     if (needConvert) {
         buffer.resize(blockSize * (bpp == 2 ? 2 : 1));
     }
-- 
2.51.0

