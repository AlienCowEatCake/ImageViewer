From 4f899958dcc697308c772298dcbd5afd3722bad7 Mon Sep 17 00:00:00 2001
From: Peter Zhigalov <peter.zhigalov@gmail.com>
Date: Sat, 9 Aug 2025 21:12:08 +0700
Subject: [PATCH 8/8] Dont use modern options with old Qt verson

---
 src/imageformats/ani.cpp               |   4 +
 src/imageformats/ani_p.h               |  16 +++
 src/imageformats/avif.cpp              |  21 +++-
 src/imageformats/chunks.cpp            | 118 ++++++++++++++++-----
 src/imageformats/chunks_p.h            |  51 ++++++++++
 src/imageformats/dds.cpp               | 136 +++++++++++++++++++++++++
 src/imageformats/exr.cpp               |  38 +++++++
 src/imageformats/hdr.cpp               |  27 ++++-
 src/imageformats/heif.cpp              |  11 +-
 src/imageformats/iff.cpp               |  10 +-
 src/imageformats/jp2.cpp               |  18 ++++
 src/imageformats/jxl.cpp               |  79 +++++++++++++-
 src/imageformats/jxl_p.h               |   8 ++
 src/imageformats/jxr.cpp               |  25 ++++-
 src/imageformats/microexif.cpp         |  32 ++++++
 src/imageformats/pcx.cpp               |   2 +
 src/imageformats/pfm.cpp               |  26 +++++
 src/imageformats/pic.cpp               |   2 +
 src/imageformats/psd.cpp               |  60 ++++++++++-
 src/imageformats/pxr.cpp               |   2 +-
 src/imageformats/ras.cpp               |  14 ++-
 src/imageformats/raw.cpp               |   2 +
 src/imageformats/rgb.cpp               |  28 +++++
 src/imageformats/scanlineconverter.cpp |   6 ++
 src/imageformats/sct.cpp               |   2 +
 src/imageformats/tga.cpp               |  15 +++
 src/imageformats/util_p.h              |  11 +-
 src/imageformats/xcf.cpp               |  43 +++++++-
 28 files changed, 768 insertions(+), 39 deletions(-)

diff --git a/src/imageformats/ani.cpp b/src/imageformats/ani.cpp
index fc0cccc..cfb3294 100644
--- a/src/imageformats/ani.cpp
+++ b/src/imageformats/ani.cpp
@@ -387,7 +387,11 @@ bool ANIHandler::ensureScanned() const
             }
 
             // TODO should we check that the number of rate entries matches nSteps?
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
             QList<int> list;
+#else
+            QVector<int> list;
+#endif
             for (unsigned int i = 0; i < chunkSize; i += sizeof(quint32_le)) {
                 const QByteArray data = device()->read(sizeof(quint32_le));
                 if (data.size() != sizeof(quint32_le)) {
diff --git a/src/imageformats/ani_p.h b/src/imageformats/ani_p.h
index bfce9ef..7b8435b 100644
--- a/src/imageformats/ani_p.h
+++ b/src/imageformats/ani_p.h
@@ -10,6 +10,10 @@
 #include <QImageIOPlugin>
 #include <QSize>
 
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
+
 class ANIHandler : public QImageIOHandler
 {
 public:
@@ -41,14 +45,26 @@ private:
     int m_frameCount = 0; // "physical" frames
     int m_imageCount = 0; // logical images
     // Stores a custom sequence of images
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<int> m_imageSequence;
+#else
+    QVector<int> m_imageSequence;
+#endif
     // and the corresponding offsets where they are
     // since we can't read the image data sequentally in this case then
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<qint64> m_frameOffsets;
+#else
+    QVector<qint64> m_frameOffsets;
+#endif
     qint64 m_firstFrameOffset = 0;
 
     int m_displayRate = 0;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<int> m_displayRates;
+#else
+    QVector<int> m_displayRates;
+#endif
 
     QString m_name;
     QString m_artist;
diff --git a/src/imageformats/avif.cpp b/src/imageformats/avif.cpp
index 3b29349..f73e057 100644
--- a/src/imageformats/avif.cpp
+++ b/src/imageformats/avif.cpp
@@ -299,7 +299,9 @@ bool QAVIFHandler::decode_one_frame()
         colorspace = QColorSpace::fromIccProfile(icc_data);
         if (!colorspace.isValid()) {
             qCWarning(LOG_AVIFPLUGIN, "AVIF image has Qt-unsupported or invalid ICC profile!");
-        } else {
+        }
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 8, 0))
+        else {
             if (colorspace.colorModel() == QColorSpace::ColorModel::Cmyk) {
                 qCWarning(LOG_AVIFPLUGIN, "CMYK ICC profile is not extected for AVIF, discarding the ICCprofile!");
                 colorspace = QColorSpace();
@@ -329,6 +331,7 @@ bool QAVIFHandler::decode_one_frame()
                 }
             }
         }
+#endif
     } else {
         float prim[8] = {0.64f, 0.33f, 0.3f, 0.6f, 0.15f, 0.06f, 0.3127f, 0.329f};
         // outPrimaries: rX, rY, gX, gY, bX, bY, wX, wY
@@ -363,12 +366,14 @@ bool QAVIFHandler::decode_one_frame()
         case 13:
             q_trc = QColorSpace::TransferFunction::SRgb;
             break;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 8, 0))
         case 16: /* AVIF_TRANSFER_CHARACTERISTICS_PQ */
             q_trc = QColorSpace::TransferFunction::St2084;
             break;
         case 18: /* AVIF_TRANSFER_CHARACTERISTICS_HLG */
             q_trc = QColorSpace::TransferFunction::Hlg;
             break;
+#endif
         default:
             qCWarning(LOG_AVIFPLUGIN, "CICP colorPrimaries: %d, transferCharacteristics: %d\nThe colorspace is unsupported by this plug-in yet.",
                      m_decoder->image->colorPrimaries,
@@ -378,9 +383,11 @@ bool QAVIFHandler::decode_one_frame()
         }
 
         if (q_trc != QColorSpace::TransferFunction::Custom) { // we create new colorspace using Qt
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 8, 0))
             if (loadgray) {
                 colorspace = QColorSpace(whitePoint, q_trc, q_trc_gamma);
             } else {
+#endif
                 switch (m_decoder->image->colorPrimaries) {
                 /* AVIF_COLOR_PRIMARIES_BT709 */
                 case 0:
@@ -396,7 +403,9 @@ bool QAVIFHandler::decode_one_frame()
                     colorspace = QColorSpace(whitePoint, redPoint, greenPoint, bluePoint, q_trc, q_trc_gamma);
                     break;
                 }
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 8, 0))
             }
+#endif
         }
 
         if (!colorspace.isValid()) {
@@ -744,12 +753,14 @@ bool QAVIFHandler::write(const QImage &image)
                 /* AVIF_TRANSFER_CHARACTERISTICS_SRGB */
                 avif->transferCharacteristics = (avifTransferCharacteristics)13;
                 break;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 8, 0))
             case QColorSpace::TransferFunction::St2084:
                 avif->transferCharacteristics = (avifTransferCharacteristics)16;
                 break;
             case QColorSpace::TransferFunction::Hlg:
                 avif->transferCharacteristics = (avifTransferCharacteristics)18;
                 break;
+#endif
             default:
                 /* AVIF_TRANSFER_CHARACTERISTICS_UNSPECIFIED */
                 break;
@@ -794,6 +805,7 @@ bool QAVIFHandler::write(const QImage &image)
             }
         }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
         QImage tmpcolorimage;
         auto cs = image.colorSpace();
         if (cs.isValid() && cs.colorModel() == QColorSpace::ColorModel::Cmyk && image.format() == QImage::Format_CMYK8888) {
@@ -808,6 +820,9 @@ bool QAVIFHandler::write(const QImage &image)
         } else {
             tmpcolorimage = image.convertToFormat(tmpformat);
         }
+#else
+        QImage tmpcolorimage = image.convertToFormat(tmpformat);
+#endif
 
         avifPixelFormat pixel_format = AVIF_PIXEL_FORMAT_YUV420;
         if (m_quality >= KIMG_AVIF_QUALITY_HIGH) {
@@ -867,12 +882,14 @@ bool QAVIFHandler::write(const QImage &image)
                 /* AVIF_TRANSFER_CHARACTERISTICS_SRGB */
                 transfer_to_save = (avifTransferCharacteristics)13;
                 break;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 8, 0))
             case QColorSpace::TransferFunction::St2084:
                 transfer_to_save = (avifTransferCharacteristics)16;
                 break;
             case QColorSpace::TransferFunction::Hlg:
                 transfer_to_save = (avifTransferCharacteristics)18;
                 break;
+#endif
             default:
                 /* AVIF_TRANSFER_CHARACTERISTICS_UNSPECIFIED */
                 transfer_to_save = (avifTransferCharacteristics)2;
@@ -908,12 +925,14 @@ bool QAVIFHandler::write(const QImage &image)
                         case 5: // AVIF_TRANSFER_CHARACTERISTICS_BT470BG
                             tmpcolorimage.convertToColorSpace(QColorSpace(QColorSpace::Primaries::SRgb, 2.8f));
                             break;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 8, 0))
                         case 16:
                             tmpcolorimage.convertToColorSpace(QColorSpace(QColorSpace::Primaries::SRgb, QColorSpace::TransferFunction::St2084));
                             break;
                         case 18:
                             tmpcolorimage.convertToColorSpace(QColorSpace(QColorSpace::Primaries::SRgb, QColorSpace::TransferFunction::Hlg));
                             break;
+#endif
                         default: // AVIF_TRANSFER_CHARACTERISTICS_SRGB + any other
                             tmpcolorimage.convertToColorSpace(QColorSpace(QColorSpace::Primaries::SRgb, QColorSpace::TransferFunction::SRgb));
                             transfer_to_save = (avifTransferCharacteristics)13;
diff --git a/src/imageformats/chunks.cpp b/src/imageformats/chunks.cpp
index b29f6b8..797ac3d 100644
--- a/src/imageformats/chunks.cpp
+++ b/src/imageformats/chunks.cpp
@@ -32,7 +32,11 @@ static QString dataToString(const IFFChunk *chunk)
         return {};
     }
     auto dt = chunk->data();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
     for (; dt.endsWith(char()); dt = dt.removeLast());
+#else
+    for (; dt.endsWith(char()) && !dt.isEmpty(); dt.remove(dt.size() - 1, 1));
+#endif
     return QString::fromUtf8(dt).trimmed();
 }
 
@@ -529,7 +533,11 @@ qint32 CMAPChunk::count() const
     return dataBytes() / 3;
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> CMAPChunk::palette(bool halfbride) const
+#else
+QVector<QRgb> CMAPChunk::palette(bool halfbride) const
+#endif
 {
     auto p = innerPalette();
     if (!halfbride) {
@@ -547,9 +555,17 @@ bool CMAPChunk::innerReadStructure(QIODevice *d)
     return cacheData(d);
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> CMAPChunk::innerPalette() const
+#else
+QVector<QRgb> CMAPChunk::innerPalette() const
+#endif
 {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> l;
+#else
+    QVector<QRgb> l;
+#endif
     auto &&d = data();
     for (qint32 i = 0, n = count(); i < n; ++i) {
         auto i3 = i * 3;
@@ -586,9 +602,17 @@ qint32 CMYKChunk::count() const
     return dataBytes() / 4;
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> CMYKChunk::innerPalette() const
+#else
+QVector<QRgb> CMYKChunk::innerPalette() const
+#endif
 {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> l;
+#else
+    QVector<QRgb> l;
+#endif
     auto &&d = data();
     for (qint32 i = 0, n = count(); i < n; ++i) {
         auto i4 = i * 4;
@@ -1120,21 +1144,21 @@ QByteArray BODYChunk::deinterleave(const QByteArray &planes, qint32 y, const BMH
                     auto v = planes.at(k * rowLen + i);
                     auto msk = 1 << k;
                     if (v & (1 << 7))
-                        ba[i8] |= msk;
+                        ba[i8 + 0] = ba[i8 + 0] | msk;
                     if (v & (1 << 6))
-                        ba[i8 + 1] |= msk;
+                        ba[i8 + 1] = ba[i8 + 1] | msk;
                     if (v & (1 << 5))
-                        ba[i8 + 2] |= msk;
+                        ba[i8 + 2] = ba[i8 + 2] | msk;
                     if (v & (1 << 4))
-                        ba[i8 + 3] |= msk;
+                        ba[i8 + 3] = ba[i8 + 3] | msk;
                     if (v & (1 << 3))
-                        ba[i8 + 4] |= msk;
+                        ba[i8 + 4] = ba[i8 + 4] | msk;
                     if (v & (1 << 2))
-                        ba[i8 + 5] |= msk;
+                        ba[i8 + 5] = ba[i8 + 5] | msk;
                     if (v & (1 << 1))
-                        ba[i8 + 6] |= msk;
+                        ba[i8 + 6] = ba[i8 + 6] | msk;
                     if (v & 1)
-                        ba[i8 + 7] |= msk;
+                        ba[i8 + 7] = ba[i8 + 7] | msk;
                 }
             }
         }
@@ -1156,21 +1180,21 @@ QByteArray BODYChunk::deinterleave(const QByteArray &planes, qint32 y, const BMH
                     auto k8 = k * 8;
                     auto msk = (1 << (7 - j));
                     if (planes.at(k8 * rowLen + i) & msk)
-                        ba[cnt] |= 0x01;
+                        ba[cnt] = ba[cnt] | 0x01;
                     if (planes.at((1 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x02;
+                        ba[cnt] = ba[cnt] | 0x02;
                     if (planes.at((2 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x04;
+                        ba[cnt] = ba[cnt] | 0x04;
                     if (planes.at((3 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x08;
+                        ba[cnt] = ba[cnt] | 0x08;
                     if (planes.at((4 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x10;
+                        ba[cnt] = ba[cnt] | 0x10;
                     if (planes.at((5 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x20;
+                        ba[cnt] = ba[cnt] | 0x20;
                     if (planes.at((6 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x40;
+                        ba[cnt] = ba[cnt] | 0x40;
                     if (planes.at((7 + k8) * rowLen + i) & msk)
-                        ba[cnt] |= 0x80;
+                        ba[cnt] = ba[cnt] | 0x80;
                 }
         }
         break;
@@ -1211,21 +1235,21 @@ QByteArray BODYChunk::deinterleave(const QByteArray &planes, qint32 y, const BMH
                     auto msk = (1 << (7 - j));
                     auto idx = cnt + order[k];
                     if (planes.at(k8 * rowLen + i) & msk)
-                        ba[idx] |= 0x01;
+                        ba[idx] = ba[idx] | 0x01;
                     if (planes.at((1 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x02;
+                        ba[idx] = ba[idx] | 0x02;
                     if (planes.at((2 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x04;
+                        ba[idx] = ba[idx] | 0x04;
                     if (planes.at((3 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x08;
+                        ba[idx] = ba[idx] | 0x08;
                     if (planes.at((4 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x10;
+                        ba[idx] = ba[idx] | 0x10;
                     if (planes.at((5 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x20;
+                        ba[idx] = ba[idx] | 0x20;
                     if (planes.at((6 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x40;
+                        ba[idx] = ba[idx] | 0x40;
                     if (planes.at((7 + k8) * rowLen + i) & msk)
-                        ba[idx] |= 0x80;
+                        ba[idx] = ba[idx] | 0x80;
                 }
                 if (p == 6) { // RGBX wants unused X data set to 0xFF
                     ba[cnt + 6] = char(0xFF);
@@ -2397,13 +2421,21 @@ IPALChunk *BEAMChunk::clone() const
     return new BEAMChunk(*this);
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 bool BEAMChunk::initialize(const QList<QRgb> &, qint32 height)
+#else
+bool BEAMChunk::initialize(const QVector<QRgb> &, qint32 height)
+#endif
 {
     _height = height;
     return true;
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> BEAMChunk::palette(qint32 y) const
+#else
+QVector<QRgb> BEAMChunk::palette(qint32 y) const
+#endif
 {
     auto &&height = _height;
     if (height < 1) {
@@ -2415,7 +2447,11 @@ QList<QRgb> BEAMChunk::palette(qint32 y) const
     }
     auto col = qint32(bpp / 2);
     auto &&dt = data();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> pal;
+#else
+    QVector<QRgb> pal;
+#endif
     for (auto c = 0; c < col; ++c) {
         // 2 bytes per color (0x0R 0xGB)
         auto idx = bpp * y + c * 2;
@@ -2491,7 +2527,11 @@ IPALChunk *SHAMChunk::clone() const
     return new SHAMChunk(*this);
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> SHAMChunk::palette(qint32 y) const
+#else
+QVector<QRgb> SHAMChunk::palette(qint32 y) const
+#endif
 {
     auto && height = _height;
     if (height < 1) {
@@ -2508,7 +2548,11 @@ QList<QRgb> SHAMChunk::palette(qint32 y) const
         return {};
     }
     auto &&dt = data();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> pal;
+#else
+    QVector<QRgb> pal;
+#endif
     for (auto c = 0, col = bpp / 2, idx0 = y / div * bpp + 2; c < col; ++c) {
         // 2 bytes per color (0x0R 0xGB)
         auto idx = idx0 + c * 2;
@@ -2522,7 +2566,11 @@ QList<QRgb> SHAMChunk::palette(qint32 y) const
     return pal;
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 bool SHAMChunk::initialize(const QList<QRgb> &, qint32 height)
+#else
+bool SHAMChunk::initialize(const QVector<QRgb> &, qint32 height)
+#endif
 {
     _height = height;
     return true;
@@ -2559,7 +2607,11 @@ IPALChunk *RASTChunk::clone() const
     return new RASTChunk(*this);
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> RASTChunk::palette(qint32 y) const
+#else
+QVector<QRgb> RASTChunk::palette(qint32 y) const
+#endif
 {
     auto &&height = _height;
     if (height < 1) {
@@ -2571,7 +2623,11 @@ QList<QRgb> RASTChunk::palette(qint32 y) const
     }
     auto col = qint32(bpp / 2 - 1);
     auto &&dt = data();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> pal;
+#else
+    QVector<QRgb> pal;
+#endif
     for (auto c = 0; c < col; ++c) {
         auto idx = bpp * y + 2 + c * 2;
         if (idx + 1 < dt.size()) {
@@ -2590,7 +2646,11 @@ QList<QRgb> RASTChunk::palette(qint32 y) const
     return pal;
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 bool RASTChunk::initialize(const QList<QRgb> &, qint32 height)
+#else
+bool RASTChunk::initialize(const QVector<QRgb> &, qint32 height)
+#endif
 {
     _height = height;
     return true;
@@ -2704,7 +2764,11 @@ IPALChunk *PCHGChunk::clone() const
     return new PCHGChunk(*this);
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> PCHGChunk::palette(qint32 y) const
+#else
+QVector<QRgb> PCHGChunk::palette(qint32 y) const
+#endif
 {
     return _palettes.value(y);
 }
@@ -2891,7 +2955,11 @@ static QByteArray pchgFastDecomp(const QByteArray& input, int treeSize, int orig
 
 // !Huffman decompression
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 bool PCHGChunk::initialize(const QList<QRgb> &cmapPalette, qint32 height)
+#else
+bool PCHGChunk::initialize(const QVector<QRgb> &cmapPalette, qint32 height)
+#endif
 {
     Q_UNUSED(height)
     auto dt = data().mid(20);
@@ -2976,7 +3044,7 @@ bool PCHGChunk::initialize(const QList<QRgb> &cmapPalette, qint32 height)
             return false;
         }
 
-        for (auto i = qsizetype(), n = last.size(); i < n; ++i) {
+        for (qsizetype i = 0, n = last.size(); i < n; ++i) {
             if (hash.contains(i))
                 last[i] = hash.value(i);
         }
diff --git a/src/imageformats/chunks_p.h b/src/imageformats/chunks_p.h
index bb9d485..fc348c1 100644
--- a/src/imageformats/chunks_p.h
+++ b/src/imageformats/chunks_p.h
@@ -24,6 +24,9 @@
 #include <QPoint>
 #include <QSize>
 #include <QSharedPointer>
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
 
 #include "microexif_p.h"
 
@@ -401,7 +404,11 @@ public:
      * \param y The scanline.
      * \return The modified palette.
      */
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> palette(qint32 y) const = 0;
+#else
+    virtual QVector<QRgb> palette(qint32 y) const = 0;
+#endif
 
     /*!
      * \brief initialize
@@ -410,7 +417,11 @@ public:
      * \param height The image height.
      * \return True on success, otherwise false.
      */
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual bool initialize(const QList<QRgb>& cmapPalette, qint32 height) = 0;
+#else
+    virtual bool initialize(const QVector<QRgb>& cmapPalette, qint32 height) = 0;
+#endif
 };
 
 
@@ -573,12 +584,20 @@ public:
      * \return The color palette.
      * \note If \a halfbride is true, the returned palette size is count() * 2.
      */
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> palette(bool halfbride = false) const;
+#else
+    QVector<QRgb> palette(bool halfbride = false) const;
+#endif
 
     CHUNKID_DEFINE(CMAP_CHUNK)
 
 protected:
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> innerPalette() const;
+#else
+    virtual QVector<QRgb> innerPalette() const;
+#endif
 
     virtual bool innerReadStructure(QIODevice *d) override;
 };
@@ -616,7 +635,11 @@ protected:
      * \brief palette
      * \return The CMYK color palette converted to RGB one.
      */
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> innerPalette() const override;
+#else
+    virtual QVector<QRgb> innerPalette() const override;
+#endif
 };
 
 /*!
@@ -1420,9 +1443,15 @@ public:
 
     virtual IPALChunk *clone() const override;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> palette(qint32 y) const override;
 
     virtual bool initialize(const QList<QRgb>& cmapPalette, qint32 height) override;
+#else
+    virtual QVector<QRgb> palette(qint32 y) const override;
+
+    virtual bool initialize(const QVector<QRgb>& cmapPalette, qint32 height) override;
+#endif
 
     CHUNKID_DEFINE(BEAM_CHUNK)
 
@@ -1464,9 +1493,15 @@ public:
 
     virtual IPALChunk *clone() const override;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> palette(qint32 y) const override;
 
     virtual bool initialize(const QList<QRgb>& cmapPalette, qint32 height) override;
+#else
+    virtual QVector<QRgb> palette(qint32 y) const override;
+
+    virtual bool initialize(const QVector<QRgb>& cmapPalette, qint32 height) override;
+#endif
 
     CHUNKID_DEFINE(SHAM_CHUNK)
 
@@ -1495,9 +1530,15 @@ public:
 
     virtual IPALChunk *clone() const override;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> palette(qint32 y) const override;
 
     virtual bool initialize(const QList<QRgb>& cmapPalette, qint32 height) override;
+#else
+    virtual QVector<QRgb> palette(qint32 y) const override;
+
+    virtual bool initialize(const QVector<QRgb>& cmapPalette, qint32 height) override;
+#endif
 
     CHUNKID_DEFINE(RAST_CHUNK)
 
@@ -1556,9 +1597,15 @@ public:
 
     virtual IPALChunk *clone() const override;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     virtual QList<QRgb> palette(qint32 y) const override;
 
     virtual bool initialize(const QList<QRgb>& cmapPalette, qint32 height) override;
+#else
+    virtual QVector<QRgb> palette(qint32 y) const override;
+
+    virtual bool initialize(const QVector<QRgb>& cmapPalette, qint32 height) override;
+#endif
 
     CHUNKID_DEFINE(PCHG_CHUNK)
 
@@ -1568,7 +1615,11 @@ protected:
 private:
     QHash<qint32, QHash<quint16, QRgb>> _paletteChanges;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QHash<qint32, QList<QRgb>> _palettes;
+#else
+    QHash<qint32, QVector<QRgb>> _palettes;
+#endif
 };
 
 #endif // KIMG_CHUNKS_P_H
diff --git a/src/imageformats/dds.cpp b/src/imageformats/dds.cpp
index c636c32..2a68a47 100644
--- a/src/imageformats/dds.cpp
+++ b/src/imageformats/dds.cpp
@@ -16,6 +16,12 @@
 #include <QColorSpace>
 #include <QDataStream>
 #include <QLoggingCategory>
+#include <QDebug>
+#include <QFloat16>
+
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
 
 #include <cmath>
 
@@ -1077,6 +1083,7 @@ static inline float readFloat32(QDataStream &s)
 
 static QImage readR16F(QDataStream &s, const quint32 width, const quint32 height)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     QImage image = imageAlloc(width, height, QImage::Format_RGBX16FPx4);
     if (image.isNull()) {
         return image;
@@ -1093,6 +1100,22 @@ static QImage readR16F(QDataStream &s, const quint32 width, const quint32 height
                 return QImage();
         }
     }
+#else
+    QImage image = imageAlloc(width, height, QImage::Format_RGB32);
+    if (image.isNull()) {
+        return image;
+    }
+
+    for (quint32 y = 0; y < height; y++) {
+        QRgb *line = reinterpret_cast<QRgb *>(image.scanLine(y));
+        for (quint32 x = 0; x < width; x++) {
+            const int r = qBound<int>(0, static_cast<int>(readFloat16(s) * 255.0f), 255);
+            line[x] = qRgb(r, 0, 0);
+            if (s.status() != QDataStream::Ok)
+                return QImage();
+        }
+    }
+#endif
 
     image.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
     return image;
@@ -1100,6 +1123,7 @@ static QImage readR16F(QDataStream &s, const quint32 width, const quint32 height
 
 static QImage readRG16F(QDataStream &s, const quint32 width, const quint32 height)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     QImage image = imageAlloc(width, height, QImage::Format_RGBX16FPx4);
     if (image.isNull()) {
         return image;
@@ -1116,6 +1140,23 @@ static QImage readRG16F(QDataStream &s, const quint32 width, const quint32 heigh
                 return QImage();
         }
     }
+#else
+    QImage image = imageAlloc(width, height, QImage::Format_RGB32);
+    if (image.isNull()) {
+        return image;
+    }
+
+    for (quint32 y = 0; y < height; y++) {
+        QRgb *line = reinterpret_cast<QRgb *>(image.scanLine(y));
+        for (quint32 x = 0; x < width; x++) {
+            const int r = qBound<int>(0, static_cast<int>(readFloat16(s) * 255.0f), 255);
+            const int g = qBound<int>(0, static_cast<int>(readFloat16(s) * 255.0f), 255);
+            line[x] = qRgb(r, g, 0);
+            if (s.status() != QDataStream::Ok)
+                return QImage();
+        }
+    }
+#endif
 
     image.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
     return image;
@@ -1123,6 +1164,7 @@ static QImage readRG16F(QDataStream &s, const quint32 width, const quint32 heigh
 
 static QImage readARGB16F(QDataStream &s, const quint32 width, const quint32 height, bool alphaPremul)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     QImage image = imageAlloc(width, height, alphaPremul ? QImage::Format_RGBA16FPx4_Premultiplied : QImage::Format_RGBA16FPx4);
     if (image.isNull()) {
         return image;
@@ -1139,6 +1181,29 @@ static QImage readARGB16F(QDataStream &s, const quint32 width, const quint32 hei
                 return QImage();
         }
     }
+#else
+    QImage image = imageAlloc(width, height, QImage::Format_ARGB32);
+    if (image.isNull()) {
+        return image;
+    }
+
+    for (quint32 y = 0; y < height; y++) {
+        QRgb *line = reinterpret_cast<QRgb *>(image.scanLine(y));
+        for (quint32 x = 0; x < width; x++) {
+            const float rf = readFloat16(s);
+            const float gf = readFloat16(s);
+            const float bf = readFloat16(s);
+            const float af = readFloat16(s);
+            const int r = qBound<int>(0, static_cast<int>((alphaPremul ? (rf / af) : rf) * 255.0f), 255);
+            const int g = qBound<int>(0, static_cast<int>((alphaPremul ? (gf / af) : gf) * 255.0f), 255);
+            const int b = qBound<int>(0, static_cast<int>((alphaPremul ? (bf / af) : bf) * 255.0f), 255);
+            const int a = qBound<int>(0, static_cast<int>(af * 255.0f), 255);
+            line[x] = qRgba(r, g, b, a);
+            if (s.status() != QDataStream::Ok)
+                return QImage();
+        }
+    }
+#endif
 
     image.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
     return image;
@@ -1146,6 +1211,7 @@ static QImage readARGB16F(QDataStream &s, const quint32 width, const quint32 hei
 
 static QImage readR32F(QDataStream &s, const quint32 width, const quint32 height)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     QImage image = imageAlloc(width, height, QImage::Format_RGBX32FPx4);
     if (image.isNull()) {
         return image;
@@ -1162,6 +1228,22 @@ static QImage readR32F(QDataStream &s, const quint32 width, const quint32 height
                 return QImage();
         }
     }
+#else
+    QImage image = imageAlloc(width, height, QImage::Format_RGB32);
+    if (image.isNull()) {
+        return image;
+    }
+
+    for (quint32 y = 0; y < height; y++) {
+        QRgb *line = reinterpret_cast<QRgb *>(image.scanLine(y));
+        for (quint32 x = 0; x < width; x++) {
+            const int r = qBound<int>(0, static_cast<int>(readFloat32(s) * 255.0f), 255);
+            line[x] = qRgb(r, 0, 0);
+            if (s.status() != QDataStream::Ok)
+                return QImage();
+        }
+    }
+#endif
 
     image.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
     return image;
@@ -1169,6 +1251,7 @@ static QImage readR32F(QDataStream &s, const quint32 width, const quint32 height
 
 static QImage readRG32F(QDataStream &s, const quint32 width, const quint32 height)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     QImage image = imageAlloc(width, height, QImage::Format_RGBX32FPx4);
     if (image.isNull()) {
         return image;
@@ -1185,6 +1268,23 @@ static QImage readRG32F(QDataStream &s, const quint32 width, const quint32 heigh
                 return QImage();
         }
     }
+#else
+    QImage image = imageAlloc(width, height, QImage::Format_RGB32);
+    if (image.isNull()) {
+        return image;
+    }
+
+    for (quint32 y = 0; y < height; y++) {
+        QRgb *line = reinterpret_cast<QRgb *>(image.scanLine(y));
+        for (quint32 x = 0; x < width; x++) {
+            const int r = qBound<int>(0, static_cast<int>(readFloat32(s) * 255.0f), 255);
+            const int g = qBound<int>(0, static_cast<int>(readFloat32(s) * 255.0f), 255);
+            line[x] = qRgb(r, g, 0);
+            if (s.status() != QDataStream::Ok)
+                return QImage();
+        }
+    }
+#endif
 
     image.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
     return image;
@@ -1192,6 +1292,7 @@ static QImage readRG32F(QDataStream &s, const quint32 width, const quint32 heigh
 
 static QImage readARGB32F(QDataStream &s, const quint32 width, const quint32 height, bool alphaPremul)
 {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     QImage image = imageAlloc(width, height, alphaPremul ? QImage::Format_RGBA32FPx4_Premultiplied : QImage::Format_RGBA32FPx4);
     if (image.isNull()) {
         return image;
@@ -1208,6 +1309,29 @@ static QImage readARGB32F(QDataStream &s, const quint32 width, const quint32 hei
                 return QImage();
         }
     }
+#else
+    QImage image = imageAlloc(width, height, QImage::Format_ARGB32);
+    if (image.isNull()) {
+        return image;
+    }
+
+    for (quint32 y = 0; y < height; y++) {
+        QRgb *line = reinterpret_cast<QRgb *>(image.scanLine(y));
+        for (quint32 x = 0; x < width; x++) {
+            const float rf = readFloat32(s);
+            const float gf = readFloat32(s);
+            const float bf = readFloat32(s);
+            const float af = readFloat32(s);
+            const int r = qBound<int>(0, static_cast<int>((alphaPremul ? (rf / af) : rf) * 255.0f), 255);
+            const int g = qBound<int>(0, static_cast<int>((alphaPremul ? (gf / af) : gf) * 255.0f), 255);
+            const int b = qBound<int>(0, static_cast<int>((alphaPremul ? (bf / af) : bf) * 255.0f), 255);
+            const int a = qBound<int>(0, static_cast<int>(af * 255.0f), 255);
+            line[x] = qRgba(r, g, b, a);
+            if (s.status() != QDataStream::Ok)
+                return QImage();
+        }
+    }
+#endif
 
     image.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
     return image;
@@ -2120,8 +2244,10 @@ bool writeL8(const QImage &outImage, QDataStream &s)
     }
 
     ScanLineConverter slc(QImage::Format_Grayscale8);
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     if(outImage.colorSpace().isValid())
         slc.setTargetColorSpace(QColorSpace(QPointF(0.3127, 0.3291), QColorSpace::TransferFunction::SRgb));
+#endif
 
     for (int y = 0, h = outImage.height(); y < h; ++y) {
         const quint8 *scanLine = reinterpret_cast<const quint8*>(slc.convertedScanLine(outImage, y));
@@ -2181,7 +2307,11 @@ bool writeP8(const QImage &image, QDataStream &s)
 
     s << dds;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> palette = outImage.colorTable();
+#else
+    QVector<QRgb> palette = outImage.colorTable();
+#endif
     for (int i = 0; i < 256; ++i) {
         quint8 r = 0, g = 0, b = 0, a = 0xff;
         if (i < palette.size()) {
@@ -2217,6 +2347,7 @@ bool writeP8(const QImage &image, QDataStream &s)
     return true;
 }
 
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
 bool writeA16B16G16R16F(const QImage &outImage, QDataStream &s)
 {
     DDSHeader dds;
@@ -2338,6 +2469,7 @@ bool writeA32B32G32R32F(const QImage &outImage, QDataStream &s)
 
     return true;
 }
+#endif
 
 bool QDDSHandler::write(const QImage &outImage)
 {
@@ -2351,6 +2483,7 @@ bool QDDSHandler::write(const QImage &outImage)
     int format = m_format;
     if (format == FormatUnknown) {
         switch (outImage.format()) {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         case QImage::Format_RGBX16FPx4:
         case QImage::Format_RGBA16FPx4:
         case QImage::Format_RGBA16FPx4_Premultiplied:
@@ -2362,6 +2495,7 @@ bool QDDSHandler::write(const QImage &outImage)
         case QImage::Format_RGBA32FPx4_Premultiplied:
             format = FormatA32B32G32R32F;
             break;
+#endif
 
         case QImage::Format_Grayscale16:
         case QImage::Format_Grayscale8:
@@ -2395,6 +2529,7 @@ bool QDDSHandler::write(const QImage &outImage)
         return writeP8(outImage, s);
     }
 
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
     if (format == FormatA16B16G16R16F) {
         return writeA16B16G16R16F(outImage, s);
     }
@@ -2402,6 +2537,7 @@ bool QDDSHandler::write(const QImage &outImage)
     if (format == FormatA32B32G32R32F) {
         return writeA32B32G32R32F(outImage, s);
     }
+#endif
 
     qCWarning(LOG_DDSPLUGIN) << "Format" << formatName(format) << "is not supported";
     return false;
diff --git a/src/imageformats/exr.cpp b/src/imageformats/exr.cpp
index f801373..5b0948d 100644
--- a/src/imageformats/exr.cpp
+++ b/src/imageformats/exr.cpp
@@ -81,7 +81,10 @@
 #include <QLocale>
 #include <QLoggingCategory>
 #include <QThread>
+
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
 #include <QTimeZone>
+#endif
 
 #ifdef QT_DEBUG
 Q_LOGGING_CATEGORY(LOG_EXRPLUGIN, "kf.imageformats.plugins.exr", QtDebugMsg)
@@ -222,7 +225,11 @@ bool EXRHandler::canRead() const
 static QImage::Format imageFormat(const Imf::RgbaInputFile &file)
 {
     auto isRgba = file.channels() & Imf::RgbaChannels::WRITE_A;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
     return (isRgba ? QImage::Format_RGBA16FPx4 : QImage::Format_RGBX16FPx4);
+#else
+    return (isRgba ? QImage::Format_RGBA64 : QImage::Format_RGBX64);
+#endif
 }
 
 /*!
@@ -284,7 +291,11 @@ static void readMetadata(const Imf::Header &header, QImage &image)
         }
         auto dateTime = QDateTime::fromString(QString::fromStdString(capDate->value()), QStringLiteral("yyyy:MM:dd HH:mm:ss"));
         if (dateTime.isValid()) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
             dateTime.setTimeZone(QTimeZone::fromSecondsAheadOfUtc(off));
+#else
+            dateTime.setOffsetFromUtc(off);
+#endif
             image.setText(QStringLiteral(META_KEY_CREATIONDATE), dateTime.toString(Qt::ISODate));
         }
     }
@@ -417,6 +428,7 @@ bool EXRHandler::read(QImage *outImage)
             file.readPixels(my, std::min(my + EXR_LINES_PER_BLOCK - 1, dw.max.y));
 
             for (n = 0; n < std::min(EXR_LINES_PER_BLOCK, height - y); ++n) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
                 auto scanLine = reinterpret_cast<qfloat16 *>(image.scanLine(y + n));
                 for (int x = 0; x < width; ++x) {
                     auto xcs = x * 4;
@@ -425,6 +437,15 @@ bool EXRHandler::read(QImage *outImage)
                     *(scanLine + xcs + 2) = qfloat16(float(pixels[n][x].b));
                     *(scanLine + xcs + 3) = qfloat16(isRgba ? std::clamp(float(pixels[n][x].a), 0.f, 1.f) : 1.f);
                 }
+#else
+                auto scanLine = reinterpret_cast<QRgba64 *>(image.scanLine(y + n));
+                for (int x = 0; x < width; ++x) {
+                    *(scanLine + x) = QRgba64::fromRgba64(quint16(qBound(0.f, float(pixels[n][x].r) * 65535.f + 0.5f, 65535.f)),
+                                                          quint16(qBound(0.f, float(pixels[n][x].g) * 65535.f + 0.5f, 65535.f)),
+                                                          quint16(qBound(0.f, float(pixels[n][x].b) * 65535.f + 0.5f, 65535.f)),
+                                                          isRgba ? quint16(qBound(0.f, float(pixels[n][x].a) * 65535.f + 0.5f, 65535.f)) : quint16(65535));
+                }
+#endif
             }
         }
 
@@ -611,12 +632,17 @@ bool EXRHandler::write(const QImage &image)
         pixels.resizeErase(EXR_LINES_PER_BLOCK, width);
 
         // convert the image and write into the stream
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
         auto convFormat = image.hasAlphaChannel() ? QImage::Format_RGBA32FPx4 : QImage::Format_RGBX32FPx4;
+#else
+        auto convFormat = image.hasAlphaChannel() ? QImage::Format_RGBA64 : QImage::Format_RGBX64;
+#endif
         ScanLineConverter slc(convFormat);
         slc.setDefaultSourceColorSpace(QColorSpace(QColorSpace::SRgb));
         slc.setTargetColorSpace(QColorSpace(QColorSpace::SRgbLinear));
         for (int y = 0, n = 0; y < height; y += n) {
             for (n = 0; n < std::min(EXR_LINES_PER_BLOCK, height - y); ++n) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
                 auto scanLine = reinterpret_cast<const float *>(slc.convertedScanLine(image, y + n));
                 if (scanLine == nullptr) {
                     return false;
@@ -628,6 +654,18 @@ bool EXRHandler::write(const QImage &image)
                     pixels[n][x].b = float(*(scanLine + xcs + 2));
                     pixels[n][x].a = float(*(scanLine + xcs + 3));
                 }
+#else
+                auto scanLine = reinterpret_cast<const QRgba64 *>(slc.convertedScanLine(image, y + n));
+                if (scanLine == nullptr) {
+                    return false;
+                }
+                for (int x = 0; x < width; ++x) {
+                    pixels[n][x].r = float((scanLine + x)->red() / 65535.f);
+                    pixels[n][x].g = float((scanLine + x)->green() / 65535.f);
+                    pixels[n][x].b = float((scanLine + x)->blue() / 65535.f);
+                    pixels[n][x].a = float((scanLine + x)->alpha() / 65535.f);
+                }
+#endif
             }
             file.setFrameBuffer(&pixels[0][0] - qint64(y) * width, 1, width);
             file.writePixels(n);
diff --git a/src/imageformats/hdr.cpp b/src/imageformats/hdr.cpp
index 866ff77..d99b649 100644
--- a/src/imageformats/hdr.cpp
+++ b/src/imageformats/hdr.cpp
@@ -162,7 +162,9 @@ public:
                                           QPointF(primaries.at(2), primaries.at(3)),
                                           QPointF(primaries.at(4), primaries.at(5)),
                                           QColorSpace::TransferFunction::Linear);
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
                     cs.setDescription(QStringLiteral("Embedded RGB"));
+#endif
                     if (cs.isValid())
                         h.m_colorSpace = cs;
                 }
@@ -233,6 +235,17 @@ private:
     Header m_header;
 };
 
+#if QT_VERSION < QT_VERSION_CHECK(6, 2, 0)
+static inline uchar ClipToByte(float value)
+{
+    if (value > 255.0f) {
+        return 255;
+    }
+    // else if (value < 0.0f) return 0;  // we know value is positive.
+    return uchar(value);
+}
+#endif
+
 // read an old style line from the hdr image file
 // if 'first' is true the first byte is already read
 static bool Read_Old_Line(uchar *image, int width, QDataStream &s)
@@ -289,6 +302,7 @@ void RGBE_To_QRgbLine(uchar *image, float_T *scanline, const Header& h)
             v = 1.0f / float(1 << -e);
         }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
         auto j4 = j * 4;
         auto vn = v / 255.0f;
         if (exposure > 0) {
@@ -299,17 +313,24 @@ void RGBE_To_QRgbLine(uchar *image, float_T *scanline, const Header& h)
         scanline[j4 + 1] = float_T(float(image[1]) * vn);
         scanline[j4 + 2] = float_T(float(image[2]) * vn);
         scanline[j4 + 3] = float_T(1.0f);
+#else
+        scanline[j] = qRgb(ClipToByte(float(image[0]) * v), ClipToByte(float(image[1]) * v), ClipToByte(float(image[2]) * v));
+#endif
         image += 4;
     }
 }
 
 QImage::Format imageFormat()
 {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
 #ifdef HDR_HALF_QUALITY
     return QImage::Format_RGBX16FPx4;
 #else
     return QImage::Format_RGBX32FPx4;
 #endif
+#else
+    return QImage::Format_RGB32;
+#endif
 }
 
 // Load the HDR image.
@@ -332,11 +353,15 @@ static bool LoadHDR(QDataStream &s, const Header& h, QImage &img)
     uchar *image = reinterpret_cast<uchar *>(lineArray.data());
 
     for (int cline = 0; cline < height; cline++) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
 #ifdef HDR_HALF_QUALITY
         auto scanline = reinterpret_cast<qfloat16 *>(img.scanLine(cline));
 #else
         auto scanline = reinterpret_cast<float *>(img.scanLine(cline));
 #endif
+#else
+        auto scanline = reinterpret_cast<QRgb *>(img.scanLine(cline));
+#endif
 
         // determine scanline type
         if ((width < MINELEN) || (MAXELEN < width)) {
@@ -479,7 +504,7 @@ QVariant HDRHandler::option(ImageOption option) const
         if (auto dev = device()) {
             auto&& h = d->header(dev);
             if (h.isValid()) {
-                v = QVariant::fromValue(h.transformation());
+                v = QVariant::fromValue(int(h.transformation()));
             }
         }
     }
diff --git a/src/imageformats/heif.cpp b/src/imageformats/heif.cpp
index 5005e67..983cc38 100644
--- a/src/imageformats/heif.cpp
+++ b/src/imageformats/heif.cpp
@@ -189,6 +189,7 @@ bool HEIFHandler::write_helper(const QImage &image)
         }
     }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     QImage tmpimage;
     auto cs = image.colorSpace();
     if (cs.isValid() && cs.colorModel() == QColorSpace::ColorModel::Cmyk && image.format() == QImage::Format_CMYK8888) {
@@ -204,6 +205,9 @@ bool HEIFHandler::write_helper(const QImage &image)
     } else {
         tmpimage = image.convertToFormat(tmpformat);
     }
+#else
+    QImage tmpimage = image.convertToFormat(tmpformat);
+#endif
 
     struct heif_context *context = heif_context_alloc();
     struct heif_error err;
@@ -864,7 +868,9 @@ bool HEIFHandler::ensureDecoder()
                 QColorSpace colorspace = QColorSpace::fromIccProfile(ba);
                 if (!colorspace.isValid()) {
                     qCWarning(LOG_HEIFPLUGIN) << "HEIC image has Qt-unsupported or invalid ICC profile!";
-                } else if (colorspace.colorModel() == QColorSpace::ColorModel::Cmyk) {
+                }
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 8, 0))
+                else if (colorspace.colorModel() == QColorSpace::ColorModel::Cmyk) {
                     qCWarning(LOG_HEIFPLUGIN) << "CMYK ICC profile is not expected for HEIF, discarding the ICCprofile!";
                     colorspace = QColorSpace();
                 } else if (colorspace.colorModel() == QColorSpace::ColorModel::Gray) {
@@ -891,6 +897,7 @@ bool HEIFHandler::ensureDecoder()
                         m_current_image.convertTo(bit_depth > 8 ? QImage::Format_Grayscale16 : QImage::Format_Grayscale8);
                     }
                 }
+#endif
                 m_current_image.setColorSpace(colorspace);
             }
         } else {
@@ -927,12 +934,14 @@ bool HEIFHandler::ensureDecoder()
             case 13:
                 q_trc = QColorSpace::TransferFunction::SRgb;
                 break;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 8, 0))
             case 16:
                 q_trc = QColorSpace::TransferFunction::St2084;
                 break;
             case 18:
                 q_trc = QColorSpace::TransferFunction::Hlg;
                 break;
+#endif
             default:
                 qCWarning(LOG_HEIFPLUGIN) << "CICP color_primaries: %d, transfer_characteristics: %d\nThe colorspace is unsupported by this plug-in yet."
                                           << nclx->color_primaries
diff --git a/src/imageformats/iff.cpp b/src/imageformats/iff.cpp
index 0f24366..bdf7a9c 100644
--- a/src/imageformats/iff.cpp
+++ b/src/imageformats/iff.cpp
@@ -235,12 +235,14 @@ static void addMetadata(QImage &img, const IFOR_Chunk *form)
     if (!iccps.isEmpty()) {
         auto cs = iccps.first()->value();
         if (cs.isValid()) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
             auto iccns = IFFChunk::searchT<ICCNChunk>(form);
             if (!iccns.isEmpty()) {
                 auto desc = iccns.first()->value();
                 if (!desc.isEmpty())
                     cs.setDescription(desc);
             }
+#endif
             img.setColorSpace(cs);
         }
     }
@@ -290,7 +292,7 @@ static QImage convertIPAL(const QImage& img, const IPALChunk *ipal)
 
     auto tmp = img.convertToFormat(ipal->hasAlpha() ? FORMAT_RGBA_8BIT : FORMAT_RGB_8BIT);
     if (tmp.isNull()) {
-        qCritical(LOG_IFFPLUGIN) << "convertIPAL(): error while converting the image!";
+        qCCritical(LOG_IFFPLUGIN) << "convertIPAL(): error while converting the image!";
         return img;
     }
 
@@ -465,7 +467,11 @@ bool IFFHandler::readMayaImage(QImage *image)
         painter.drawImage(tp, ti);
     }
 #if QT_VERSION < QT_VERSION_CHECK(6, 9, 0)
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
     img.mirror(false, true);
+#else
+    img = img.mirrored(false, true);
+#endif
 #else
     img.flip(Qt::Orientation::Vertical);
 #endif
@@ -537,7 +543,7 @@ QVariant IFFHandler::option(ImageOption option) const
     }
 
     if (option == QImageIOHandler::ImageTransformation) {
-        return QVariant::fromValue(form->transformation());
+        return QVariant::fromValue(int(form->transformation()));
     }
 
     return {};
diff --git a/src/imageformats/jp2.cpp b/src/imageformats/jp2.cpp
index 3324462..32f2176 100644
--- a/src/imageformats/jp2.cpp
+++ b/src/imageformats/jp2.cpp
@@ -320,10 +320,14 @@ public:
         }
 
         auto f = img.format();
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         if (f == QImage::Format_RGBA32FPx4 || f == QImage::Format_RGBX32FPx4) {
             if (!jp2ToImage<quint32>(&img))
                 return {};
             alphaFix<float>(&img);
+#else
+        if (false) {
+#endif
         } else if (f == QImage::Format_RGBA64 || f == QImage::Format_RGBX64 || f == QImage::Format_Grayscale16) {
             if (!jp2ToImage<quint16>(&img))
                 return {};
@@ -351,6 +355,7 @@ public:
             return false;
         }
 
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
         // OpenJPEG uses a shadow copy @32-bit/channel so we need to do a check
         const int allocationLimit = QImageReader::allocationLimit();
         if (allocationLimit > 0) {
@@ -362,6 +367,7 @@ public:
                 return false;
             }
         }
+#endif
 
         return true;
     }
@@ -395,6 +401,7 @@ public:
                     prec = 0;
             }
             auto jp2cs = m_jp2_image->color_space;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
             if (jp2cs == OPJ_CLRSPC_UNKNOWN || jp2cs == OPJ_CLRSPC_UNSPECIFIED) {
                 auto cs = colorSpace();
                 if (cs.colorModel() == QColorSpace::ColorModel::Cmyk)
@@ -404,6 +411,7 @@ public:
                 else if (cs.colorModel() == QColorSpace::ColorModel::Gray)
                     jp2cs = OPJ_CLRSPC_GRAY;
             }
+#endif
             if (jp2cs == OPJ_CLRSPC_UNKNOWN || jp2cs == OPJ_CLRSPC_UNSPECIFIED) {
                 if (m_jp2_image->numcomps == 1)
                     jp2cs = OPJ_CLRSPC_GRAY;
@@ -419,9 +427,11 @@ public:
                         fmt = hasAlpha ? QImage::Format_RGBA8888 : QImage::Format_RGBX8888;
                     else if (prec == 16)
                         fmt = hasAlpha ? QImage::Format_RGBA64 : QImage::Format_RGBX64;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
 #ifdef JP2_ENABLE_HDR
                     else if (prec == 32) // not sure about this
                         fmt = hasAlpha ? QImage::Format_RGBA32FPx4 : QImage::Format_RGBX32FPx4;
+#endif
 #endif
                 }
             } else if (jp2cs == OPJ_CLRSPC_GRAY) {
@@ -433,8 +443,10 @@ public:
                 }
             } else if (jp2cs == OPJ_CLRSPC_CMYK) {
                 if (m_jp2_image->numcomps == 4) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
                     if (prec == 8 || prec == 16)
                         fmt = QImage::Format_CMYK8888;
+#endif
                 }
             }
         }
@@ -541,6 +553,7 @@ public:
             cs = OPJ_CLRSPC_GRAY;
             convFormat = QImage::Format_Grayscale16;
             break;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         case QImage::Format_RGBX16FPx4:
         case QImage::Format_RGBX32FPx4:
             isFloat = true;
@@ -551,6 +564,7 @@ public:
             break;
 #else
             Q_FALLTHROUGH();
+#endif
 #endif
         case QImage::Format_RGBX64:
         case QImage::Format_RGB30:
@@ -559,6 +573,7 @@ public:
             convFormat = QImage::Format_RGBX64;
             break;
 
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         case QImage::Format_RGBA16FPx4:
         case QImage::Format_RGBA16FPx4_Premultiplied:
         case QImage::Format_RGBA32FPx4:
@@ -571,6 +586,7 @@ public:
             break;
 #else
             Q_FALLTHROUGH();
+#endif
 #endif
         case QImage::Format_RGBA64:
         case QImage::Format_RGBA64_Premultiplied:
@@ -579,6 +595,7 @@ public:
             prec = 16;
             convFormat = QImage::Format_RGBA64;
             break;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
         case QImage::Format_CMYK8888: // requires OpenJPEG 2.5.3+
             if (opjVersion() >= QT_VERSION_CHECK(2, 5, 3)) {
                 ncomp = 4;
@@ -587,6 +604,7 @@ public:
             } else {
                 Q_FALLTHROUGH();
             }
+#endif
         default:
             if (image.depth() > 32) {
                 qCWarning(LOG_JP2PLUGIN) << "The image is saved losing precision!";
diff --git a/src/imageformats/jxl.cpp b/src/imageformats/jxl.cpp
index 1ea1a2b..59a3fad 100644
--- a/src/imageformats/jxl.cpp
+++ b/src/imageformats/jxl.cpp
@@ -9,6 +9,7 @@
 #include <QLoggingCategory>
 #include <QThread>
 #include <QtGlobal>
+#include <QFloat16>
 
 #include "jxl_p.h"
 #include "microexif_p.h"
@@ -69,15 +70,19 @@ Q_LOGGING_CATEGORY(LOG_JXLPLUGIN, "kf.imageformats.plugins.jxl", QtDebugMsg)
 Q_LOGGING_CATEGORY(LOG_JXLPLUGIN, "kf.imageformats.plugins.jxl", QtWarningMsg)
 #endif
 
+
+// Avoid rotation on buggy Qts (see also https://bugreports.qt.io/browse/QTBUG-126575)
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 5, 7) && QT_VERSION < QT_VERSION_CHECK(6, 6, 0)) || (QT_VERSION >= QT_VERSION_CHECK(6, 7, 3))
 #ifndef JXL_QT_AUTOTRANSFORM
 #define JXL_QT_AUTOTRANSFORM
 #endif
+#endif
 
 #ifndef JXL_HDR_PRESERVATION_DISABLED
 // Define JXL_HDR_PRESERVATION_DISABLED to disable HDR preservation
 // (HDR images are saved as UINT16).
 // #define JXL_HDR_PRESERVATION_DISABLED
-#if JPEGXL_NUMERIC_VERSION >= JPEGXL_COMPUTE_NUMERIC_VERSION(0, 9, 0)
+#if JPEGXL_NUMERIC_VERSION >= JPEGXL_COMPUTE_NUMERIC_VERSION(0, 9, 0) || (QT_VERSION < QT_VERSION_CHECK(6, 2, 0))
 #define JXL_HDR_PRESERVATION_DISABLED
 #endif
 #endif
@@ -341,6 +346,7 @@ bool QJpegXLHandler::countALLFrames()
             m_input_pixel_format.num_channels = 1;
             m_input_pixel_format.data_type = JXL_TYPE_UINT16;
             m_input_image_format = m_target_image_format = QImage::Format_Grayscale16;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         } else if (m_basicinfo.bits_per_sample > 16 && is_fp) {
             m_input_pixel_format.data_type = JXL_TYPE_FLOAT;
             m_input_image_format = QImage::Format_RGBA32FPx4;
@@ -355,6 +361,15 @@ bool QJpegXLHandler::countALLFrames()
                 m_target_image_format = is_fp ? QImage::Format_RGBA16FPx4 : QImage::Format_RGBA64;
             else
                 m_target_image_format = is_fp ? QImage::Format_RGBX16FPx4 : QImage::Format_RGBX64;
+#else
+            Q_ASSERT(!is_fp);
+            m_input_pixel_format.data_type = JXL_TYPE_UINT16;
+            m_input_image_format = QImage::Format_RGBA64;
+            if (loadalpha)
+                m_target_image_format = QImage::Format_RGBA64;
+            else
+                m_target_image_format = QImage::Format_RGBX64;
+#endif
         }
     } else { // 8bit depth
         m_input_pixel_format.data_type = JXL_TYPE_UINT8;
@@ -475,6 +490,7 @@ bool QJpegXLHandler::countALLFrames()
         m_framedelays[0] = 0;
     }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     // CMYK detection
     if ((m_basicinfo.uses_original_profile == JXL_TRUE) && (m_basicinfo.num_color_channels == 3) && (m_colorspace.isValid())) {
         bool alpha_found = false;
@@ -531,6 +547,7 @@ bool QJpegXLHandler::countALLFrames()
             qCWarning(LOG_JXLPLUGIN, "JXL has CMYK colorspace but BLACK channel was not found!");
         }
     }
+#endif
 
 #ifndef JXL_DECODE_BOXES_DISABLED
     if (!decodeContainer()) {
@@ -557,6 +574,7 @@ bool QJpegXLHandler::decode_one_frame()
     }
 
     if (m_isCMYK) { // CMYK decoding
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
         uchar *pixels_cmy = nullptr;
         uchar *pixels_black = nullptr;
 
@@ -797,6 +815,11 @@ bool QJpegXLHandler::decode_one_frame()
             free(pixels_cmy);
             pixels_cmy = nullptr;
         }
+#else
+        // CMYK not supported in older Qt
+        m_parseState = ParseJpegXLError;
+        return false;
+#endif
     } else { // RGB or GRAY
         m_current_image = imageAlloc(m_basicinfo.xsize, m_basicinfo.ysize, m_input_image_format);
         if (m_current_image.isNull()) {
@@ -974,9 +997,11 @@ bool QJpegXLHandler::write(const QImage &image)
     }
 
     bool save_cmyk = false;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     if (image.format() == QImage::Format_CMYK8888 && image.colorSpace().isValid() && image.colorSpace().colorModel() == QColorSpace::ColorModel::Cmyk) {
         save_cmyk = true;
     }
+#endif
 
     JxlEncoderStatus status;
     JxlPixelFormat pixel_format;
@@ -987,6 +1012,7 @@ bool QJpegXLHandler::write(const QImage &image)
     auto xmp_data = image.text(QStringLiteral(META_KEY_XMP_ADOBE)).toUtf8();
 
     if (save_cmyk) { // CMYK is always lossless
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
         output_info.uses_original_profile = JXL_TRUE;
         output_info.xsize = image.width();
         output_info.ysize = image.height();
@@ -1159,12 +1185,20 @@ bool QJpegXLHandler::write(const QImage &image)
             JxlEncoderDestroy(encoder);
             return false;
         }
+#else
+        if (runner) {
+            JxlThreadParallelRunnerDestroy(runner);
+        }
+        JxlEncoderDestroy(encoder);
+        return false;
+#endif
     } else { // RGB or GRAY saving
         int save_depth = 8; // 8 / 16 / 32
         bool save_fp = false;
         bool is_gray = false;
         // depth detection
         switch (image.format()) {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         case QImage::Format_RGBX32FPx4:
         case QImage::Format_RGBA32FPx4:
         case QImage::Format_RGBA32FPx4_Premultiplied:
@@ -1180,6 +1214,7 @@ bool QJpegXLHandler::write(const QImage &image)
             save_depth = 16;
             save_fp = true;
             break;
+#endif
 #endif
         case QImage::Format_BGR30:
         case QImage::Format_A2BGR30_Premultiplied:
@@ -1197,7 +1232,9 @@ bool QJpegXLHandler::write(const QImage &image)
         case QImage::Format_RGBX8888:
         case QImage::Format_RGBA8888:
         case QImage::Format_RGBA8888_Premultiplied:
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
         case QImage::Format_CMYK8888:
+#endif
             save_depth = 8;
             break;
         case QImage::Format_Grayscale16:
@@ -1238,6 +1275,7 @@ bool QJpegXLHandler::write(const QImage &image)
             output_info.bits_per_sample = 8;
             tmpformat = QImage::Format_Grayscale8;
             pixel_format.num_channels = 1;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         } else if (save_depth > 16) { // 32bit depth rgb
             pixel_format.data_type = JXL_TYPE_FLOAT;
             output_info.exponent_bits_per_sample = 8;
@@ -1274,6 +1312,27 @@ bool QJpegXLHandler::write(const QImage &image)
                 output_info.alpha_bits = 0;
                 output_info.num_extra_channels = 0;
             }
+#else
+        } else if (save_depth > 8) { // 16bit depth rgb
+            Q_ASSERT(!save_fp);
+            pixel_format.data_type = JXL_TYPE_UINT16;
+            output_info.exponent_bits_per_sample = 0;
+            output_info.num_color_channels = 3;
+            output_info.bits_per_sample = 16;
+
+            if (image.hasAlphaChannel()) {
+                tmpformat = QImage::Format_RGBA64;
+                pixel_format.num_channels = 4;
+                output_info.alpha_bits = 16;
+                output_info.alpha_exponent_bits = 0;
+                output_info.num_extra_channels = 1;
+            } else {
+                tmpformat = QImage::Format_RGBX64;
+                pixel_format.num_channels = 3;
+                output_info.alpha_bits = 0;
+                output_info.num_extra_channels = 0;
+            }
+#endif
         } else { // 8bit depth rgb
             pixel_format.data_type = JXL_TYPE_UINT8;
             output_info.num_color_channels = 3;
@@ -1292,6 +1351,7 @@ bool QJpegXLHandler::write(const QImage &image)
             }
         }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
         QImage tmpimage;
         if (image.colorSpace().isValid()) {
             if (is_gray && image.colorSpace().colorModel() != QColorSpace::ColorModel::Gray) {
@@ -1344,6 +1404,9 @@ bool QJpegXLHandler::write(const QImage &image)
         } else { // no ColorSpace or invalid
             tmpimage = image.convertToFormat(tmpformat);
         }
+#else
+        QImage tmpimage = image.convertToFormat(tmpformat);
+#endif
 
         output_info.xsize = tmpimage.width();
         output_info.ysize = tmpimage.height();
@@ -1369,7 +1432,10 @@ bool QJpegXLHandler::write(const QImage &image)
             output_info.uses_original_profile = JXL_FALSE;
 
             if (tmpimage.colorSpace().isValid()) {
-                const QPointF whiteP = image.colorSpace().whitePoint();
+                QPointF whiteP(0.3127f, 0.329f);
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
+                whiteP = image.colorSpace().whitePoint();
+#endif
 
                 switch (tmpimage.colorSpace().primaries()) {
                 case QColorSpace::Primaries::SRgb:
@@ -1398,6 +1464,9 @@ bool QJpegXLHandler::write(const QImage &image)
                     break;
                 case QColorSpace::Primaries::ProPhotoRgb:
                     color_profile.white_point = JXL_WHITE_POINT_CUSTOM;
+#if QT_VERSION < QT_VERSION_CHECK(6, 8, 0)
+                    whiteP = QPointF(0.3457f, 0.3585f);
+#endif
                     color_profile.white_point_xy[0] = whiteP.x();
                     color_profile.white_point_xy[1] = whiteP.y();
                     color_profile.primaries = JXL_PRIMARIES_CUSTOM;
@@ -1408,6 +1477,7 @@ bool QJpegXLHandler::write(const QImage &image)
                     color_profile.primaries_blue_xy[0] = 0.0366;
                     color_profile.primaries_blue_xy[1] = 0.0001;
                     break;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
                 case QColorSpace::Primaries::Bt2020:
                     color_profile.white_point = JXL_WHITE_POINT_D65;
                     color_profile.primaries = JXL_PRIMARIES_2100;
@@ -1418,6 +1488,7 @@ bool QJpegXLHandler::write(const QImage &image)
                     color_profile.primaries_blue_xy[0] = 0.131;
                     color_profile.primaries_blue_xy[1] = 0.046;
                     break;
+#endif
                 default:
                     if (is_gray && !whiteP.isNull()) {
                         color_profile.white_point = JXL_WHITE_POINT_CUSTOM;
@@ -1526,6 +1597,7 @@ bool QJpegXLHandler::write(const QImage &image)
         }
 
         size_t buffer_size;
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         if (tmpimage.format() == QImage::Format_RGBX32FPx4) { // pack 32-bit depth RGBX -> RGB
             buffer_size = 12 * size_t(tmpimage.width()) * size_t(tmpimage.height());
 
@@ -1554,6 +1626,9 @@ bool QJpegXLHandler::write(const QImage &image)
             status = JxlEncoderAddImageFrame(encoder_options, &pixel_format, packed_pixels32, buffer_size);
             free(packed_pixels32);
         } else if (tmpimage.format() == QImage::Format_RGBX16FPx4 || tmpimage.format() == QImage::Format_RGBX64) {
+#else
+        if (tmpimage.format() == QImage::Format_RGBX64) {
+#endif
             // pack 16-bit depth RGBX -> RGB
             buffer_size = 6 * size_t(tmpimage.width()) * size_t(tmpimage.height());
 
diff --git a/src/imageformats/jxl_p.h b/src/imageformats/jxl_p.h
index c062584..ef1fac6 100644
--- a/src/imageformats/jxl_p.h
+++ b/src/imageformats/jxl_p.h
@@ -17,6 +17,10 @@
 #include <QList>
 #include <QVariant>
 
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
+
 #include <jxl/decode.h>
 
 class QJpegXLHandler : public QImageIOHandler
@@ -74,7 +78,11 @@ private:
     void *m_runner;
     JxlBasicInfo m_basicinfo;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<int> m_framedelays;
+#else
+    QVector<int> m_framedelays;
+#endif
     int m_next_image_delay;
 
     QImage m_current_image;
diff --git a/src/imageformats/jxr.cpp b/src/imageformats/jxr.cpp
index d528f75..e28e9cf 100644
--- a/src/imageformats/jxr.cpp
+++ b/src/imageformats/jxr.cpp
@@ -46,6 +46,9 @@ Q_LOGGING_CATEGORY(LOG_JXRPLUGIN, "kf.imageformats.plugins.jxr", QtWarningMsg)
  * NOTE: Float images have values greater than 1 so they need an additional in place conversion.
  */
 // #define JXR_DENY_FLOAT_IMAGE
+#if QT_VERSION < QT_VERSION_CHECK(6, 2, 0)
+#define JXR_DENY_FLOAT_IMAGE
+#endif
 
 /*!
  * Remove the needs of additional memory by disabling the conversion between
@@ -582,7 +585,9 @@ public:
         // IMPORTANT: these values must be in exactMatchingFormat()
         // clang-format off
         auto valid = QSet<QImage::Format>()
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
             << QImage::Format_CMYK8888
+#endif
 #ifndef JXR_DENY_FLOAT_IMAGE
             << QImage::Format_RGBA16FPx4
             << QImage::Format_RGBX16FPx4
@@ -647,8 +652,8 @@ public:
             if (cs.isValid() && cs.transferFunction() != QColorSpace::TransferFunction::Linear) {
                 qi = qi.convertedToColorSpace(QColorSpace(QColorSpace::SRgbLinear));
             }
-        }
 #endif // JXR_DENY_FLOAT_IMAGE
+        }
 
         return qi;
     }
@@ -672,8 +677,10 @@ public:
         wmiSCP->bVerbose = FALSE;
         if (fmt == QImage::Format_Grayscale8 || fmt == QImage::Format_Grayscale16 || fmt == QImage::Format_Mono)
             wmiSCP->cfColorFormat = Y_ONLY;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
         else if (fmt == QImage::Format_CMYK8888)
             wmiSCP->cfColorFormat = CMYK;
+#endif
         else
             wmiSCP->cfColorFormat = YUV_444;
         wmiSCP->bdBitDepth = BD_LONG;
@@ -811,8 +818,10 @@ private:
             << std::pair<QImage::Format, PKPixelFormatGUID>(QImage::Format_RGBA32FPx4_Premultiplied, GUID_PKPixelFormat128bppPRGBAFloat)
             << std::pair<QImage::Format, PKPixelFormatGUID>(QImage::Format_RGBX32FPx4, GUID_PKPixelFormat128bppRGBFloat)
 #endif // JXR_DENY_FLOAT_IMAGE
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
             << std::pair<QImage::Format, PKPixelFormatGUID>(QImage::Format_CMYK8888, GUID_PKPixelFormat32bppCMYK)
             << std::pair<QImage::Format, PKPixelFormatGUID>(QImage::Format_CMYK8888, GUID_PKPixelFormat32bppCMYKDIRECT)
+#endif
             << std::pair<QImage::Format, PKPixelFormatGUID>(QImage::Format_Mono, GUID_PKPixelFormatBlackWhite)
             << std::pair<QImage::Format, PKPixelFormatGUID>(QImage::Format_Grayscale8, GUID_PKPixelFormat8bppGray)
             << std::pair<QImage::Format, PKPixelFormatGUID>(QImage::Format_Grayscale16, GUID_PKPixelFormat16bppGray)
@@ -1015,11 +1024,13 @@ bool JXRHandler::read(QImage *outImage)
         } else { // additional buffer needed
             qint64 convStrideSize = (img.width() * d->pDecoder->WMP.wmiI.cBitsPerUnit + 7) / 8;
             qint64 buffSize = convStrideSize * img.height();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
             qint64 limit = QImageReader::allocationLimit();
             if (limit && (buffSize + img.sizeInBytes()) > limit * 1024 * 1024) {
                 qCWarning(LOG_JXRPLUGIN) << "JXRHandler::read() unable to covert due to allocation limit set:" << limit << "MiB";
                 return false;
             }
+#endif
             QVector<quint8> ba(buffSize);
             if (auto err = pConverter->Copy(pConverter, &rect, ba.data(), convStrideSize)) {
                 PKFormatConverter_Release(&pConverter);
@@ -1095,15 +1106,27 @@ bool JXRHandler::write(const QImage &image)
 #ifndef JXR_DISABLE_BGRA_HACK
     if (IsEqualGUID(jxlfmt, GUID_PKPixelFormat32bppRGB)) {
         jxlfmt = GUID_PKPixelFormat32bppBGR;
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+        qi = qi.rgbSwapped();
+#else
         qi.rgbSwap();
+#endif
     }
     if (IsEqualGUID(jxlfmt, GUID_PKPixelFormat32bppRGBA)) {
         jxlfmt = GUID_PKPixelFormat32bppBGRA;
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+        qi = qi.rgbSwapped();
+#else
         qi.rgbSwap();
+#endif
     }
     if (IsEqualGUID(jxlfmt, GUID_PKPixelFormat32bppPRGBA)) {
         jxlfmt = GUID_PKPixelFormat32bppPBGRA;
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+        qi = qi.rgbSwapped();
+#else
         qi.rgbSwap();
+#endif
     }
 #endif
 
diff --git a/src/imageformats/microexif.cpp b/src/imageformats/microexif.cpp
index c9e3fb9..20958ad 100644
--- a/src/imageformats/microexif.cpp
+++ b/src/imageformats/microexif.cpp
@@ -12,7 +12,9 @@
 #include <QCoreApplication>
 #include <QDataStream>
 #include <QHash>
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
 #include <QStringDecoder>
+#endif
 #include <QTimeZone>
 
 // TIFF 6 specs
@@ -491,14 +493,27 @@ static QByteArray readBytes(QDataStream &ds, quint32 count, bool asciiz)
     }
     char c;
     for (quint32 i = 0; i < count; ++i) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         ds >> c;
+#else
+        ds >> reinterpret_cast<qint8&>(c);
+#endif
         l.append(c);
     }
     if (asciiz && l.at(l.size() - 1) == 0) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
         l.removeLast();
+#else
+        if(!l.isEmpty())
+            l.remove(l.size() - 1, 1);
+#endif
     }
     for (auto n = count; n < 4; ++n) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         ds >> c;
+#else
+        ds >> reinterpret_cast<qint8&>(c);
+#endif
     }
     return l;
 }
@@ -562,6 +577,7 @@ static bool readIfd(QDataStream &ds, MicroExif::Tags &tags, quint32 pos = 0, con
         if (dataType == EXIF_TAG_DATATYPE(ExifTagType::Ascii) || dataType == EXIF_TAG_DATATYPE(ExifTagType::Utf8)) {
             auto l = readBytes(ds, count, true);
             if (!l.isEmpty()) {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
                 // It seems that converting to Latin 1 never detects errors so, using UTF-8.
                 // Note that if the dataType is ASCII, by EXIF specification, it must use only the
                 // first 128 values so the UTF-8 conversion is correct.
@@ -570,6 +586,10 @@ static bool readIfd(QDataStream &ds, MicroExif::Tags &tags, quint32 pos = 0, con
                 auto ut8 = QString(dec(l));
                 // If there are errors in the conversion to UTF-8, then I try with latin1 (extended ASCII)
                 tags.insert(tagId, dec.hasError() ? QString::fromLatin1(l) : ut8);
+#else
+                auto ut8 = QString::fromUtf8(l);
+                tags.insert(tagId, ut8.isEmpty() ? QString::fromLatin1(l) : ut8);
+#endif
             }
         } else if (dataType == EXIF_TAG_DATATYPE(ExifTagType::Undefined)) {
             auto l = readBytes(ds, count, false);
@@ -883,7 +903,11 @@ QDateTime MicroExif::dateTime() const
     auto dt = QDateTime::fromString(tiffString(TIFF_DATETIME), QStringLiteral("yyyy:MM:dd HH:mm:ss"));
     auto ofTag = exifString(EXIF_OFFSETTIME);
     if (dt.isValid() && !ofTag.isEmpty())
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
         dt.setTimeZone(QTimeZone::fromSecondsAheadOfUtc(timeOffset(ofTag) * 60));
+#else
+        dt.setTimeZone(QTimeZone(static_cast<int>(timeOffset(ofTag) * 60)));
+#endif
     return(dt);
 }
 
@@ -903,7 +927,11 @@ QDateTime MicroExif::dateTimeOriginal() const
     auto dt = QDateTime::fromString(exifString(EXIF_DATETIMEORIGINAL), QStringLiteral("yyyy:MM:dd HH:mm:ss"));
     auto ofTag = exifString(EXIF_OFFSETTIMEORIGINAL);
     if (dt.isValid() && !ofTag.isEmpty())
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
         dt.setTimeZone(QTimeZone::fromSecondsAheadOfUtc(timeOffset(ofTag) * 60));
+#else
+        dt.setTimeZone(QTimeZone(static_cast<int>(timeOffset(ofTag) * 60)));
+#endif
     return(dt);
 }
 
@@ -923,7 +951,11 @@ QDateTime MicroExif::dateTimeDigitized() const
     auto dt = QDateTime::fromString(exifString(EXIF_DATETIMEDIGITIZED), QStringLiteral("yyyy:MM:dd HH:mm:ss"));
     auto ofTag = exifString(EXIF_OFFSETTIMEDIGITIZED);
     if (dt.isValid() && !ofTag.isEmpty())
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
         dt.setTimeZone(QTimeZone::fromSecondsAheadOfUtc(timeOffset(ofTag) * 60));
+#else
+        dt.setTimeZone(QTimeZone(static_cast<int>(timeOffset(ofTag) * 60)));
+#endif
     return(dt);
 }
 
diff --git a/src/imageformats/pcx.cpp b/src/imageformats/pcx.cpp
index 769129b..5ec7518 100644
--- a/src/imageformats/pcx.cpp
+++ b/src/imageformats/pcx.cpp
@@ -781,11 +781,13 @@ static bool writeImage24(const QImage &image, QDataStream &s, PCXHEADER &header)
 
     auto tcs = QColorSpace();
     auto tfmt = image.format();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     auto cs = image.colorSpace();
     if (cs.isValid() && cs.colorModel() == QColorSpace::ColorModel::Cmyk && tfmt == QImage::Format_CMYK8888) {
         tcs = QColorSpace(QColorSpace::SRgb);
         tfmt = QImage::Format_RGB32;
     }
+#endif
     if (tfmt != QImage::Format_ARGB32 && tfmt != QImage::Format_RGB32) {
         tfmt = hasAlpha ? QImage::Format_ARGB32 : QImage::Format_RGB32;
     }
diff --git a/src/imageformats/pfm.cpp b/src/imageformats/pfm.cpp
index 68ace1e..a8e709f 100644
--- a/src/imageformats/pfm.cpp
+++ b/src/imageformats/pfm.cpp
@@ -131,7 +131,11 @@ public:
     QImage::Format format() const
     {
         if (isValid()) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
             return m_half ? QImage::Format_RGBX16FPx4 : QImage::Format_RGBX32FPx4;
+#else
+            return QImage::Format_RGB32;
+#endif
         }
         return QImage::Format_Invalid;
     }
@@ -233,6 +237,7 @@ template<class T>
 bool readScanLine(qint32 y, QDataStream &s, QImage &img, const PFMHeader &header)
 {
     auto bw = header.isBlackAndWhite();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
     auto line = reinterpret_cast<T *>(img.scanLine(header.isPhotoshop() ? y : img.height() - y - 1));
     for (auto x = 0, n = img.width() * 4; x < n; x += 4) {
         line[x + 3] = T(1);
@@ -244,6 +249,23 @@ bool readScanLine(qint32 y, QDataStream &s, QImage &img, const PFMHeader &header
             s >> line[x + 1];
             s >> line[x + 2];
         }
+#else
+    auto line = reinterpret_cast<QRgb *>(img.scanLine(header.isPhotoshop() ? y : img.height() - y - 1));
+    for (auto x = 0, n = img.width() * 4; x < n; x += 4) {
+        int r, g, b;
+        T f;
+        s >> f;
+        r = qBound(int(0), int(f * 255.0f), int(255));
+        if (bw) {
+            g = b = r;
+        } else {
+            s >> f;
+            g = qBound(int(0), int(f * 255.0f), int(255));
+            s >> f;
+            b = qBound(int(0), int(f * 255.0f), int(255));
+        }
+        line[x] = qRgb(r, g, b);
+#endif
         if (s.status() != QDataStream::Ok) {
             return false;
         }
@@ -296,9 +318,11 @@ bool PFMHandler::supportsOption(ImageOption option) const
     if (option == QImageIOHandler::ImageFormat) {
         return true;
     }
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
     if (option == QImageIOHandler::Endianness) {
         return true;
     }
+#endif
     return false;
 }
 
@@ -328,6 +352,7 @@ QVariant PFMHandler::option(ImageOption option) const
         }
     }
 
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 0, 0))
     if (option == QImageIOHandler::Endianness) {
         auto&& h = d->m_header;
         if (h.isValid()) {
@@ -338,6 +363,7 @@ QVariant PFMHandler::option(ImageOption option) const
             }
         }
     }
+#endif
 
     return v;
 }
diff --git a/src/imageformats/pic.cpp b/src/imageformats/pic.cpp
index b64ae3c..399ca7e 100644
--- a/src/imageformats/pic.cpp
+++ b/src/imageformats/pic.cpp
@@ -275,11 +275,13 @@ bool SoftimagePICHandler::write(const QImage &image)
     bool alpha = image.hasAlphaChannel();
     auto tcs = QColorSpace();
     auto tfmt = image.format();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     auto cs = image.colorSpace();
     if (cs.isValid() && cs.colorModel() == QColorSpace::ColorModel::Cmyk && tfmt == QImage::Format_CMYK8888) {
         tcs = QColorSpace(QColorSpace::SRgb);
         tfmt = QImage::Format_RGB32;
     }
+#endif
     if (tfmt != QImage::Format_ARGB32 && tfmt != QImage::Format_RGB32) {
         tfmt = alpha ? QImage::Format_ARGB32 : QImage::Format_RGB32;
     }
diff --git a/src/imageformats/psd.cpp b/src/imageformats/psd.cpp
index 4e391e2..40b7510 100644
--- a/src/imageformats/psd.cpp
+++ b/src/imageformats/psd.cpp
@@ -38,6 +38,10 @@
 #include <QImage>
 #include <QLoggingCategory>
 
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
+
 #include <cmath>
 #include <cstring>
 
@@ -91,7 +95,7 @@ typedef quint8 uchar;
 namespace // Private.
 {
 
-#if defined(PSD_NATIVE_CMYK_SUPPORT_DISABLED)
+#if QT_VERSION < QT_VERSION_CHECK(6, 8, 0) || defined(PSD_NATIVE_CMYK_SUPPORT_DISABLED)
 #   define CMYK_FORMAT QImage::Format_Invalid
 #else
 #   define CMYK_FORMAT QImage::Format_CMYK8888
@@ -169,7 +173,11 @@ struct PSDDuotoneOptions {
  */
 struct PSDColorModeDataSection {
     PSDDuotoneOptions duotone;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<QRgb> palette;
+#else
+    QVector<QRgb> palette;
+#endif
 };
 
 using PSDImageResourceSection = QHash<quint16, PSDImageResourceBlock>;
@@ -521,7 +529,11 @@ PSDColorModeDataSection readColorModeDataSection(QDataStream &s, bool *ok = null
             *ok = false;
     } else { // read the palette (768 bytes)
         auto &&palette = cms.palette;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         QList<quint8> vect(size);
+#else
+        QVector<quint8> vect(size);
+#endif
         for (auto &&v : vect)
             s >> v;
         for (qsizetype i = 0, n = vect.size()/3; i < n; ++i)
@@ -547,6 +559,7 @@ static bool setColorSpace(QImage &img, const PSDImageResourceSection &irs)
     if (!cs.isValid())
         return false;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     if (cs.colorModel() == QColorSpace::ColorModel::Gray && img.pixelFormat().colorModel() != QPixelFormat::Grayscale) {
         // I created an RGB from a grayscale without using color profile conversion (fast).
         // I'll try to create an RGB profile that looks the same.
@@ -558,6 +571,7 @@ static bool setColorSpace(QImage &img, const PSDImageResourceSection &irs)
                 cs = tmp;
         }
     }
+#endif
 
     img.setColorSpace(cs);
     return img.colorSpace().isValid();
@@ -781,9 +795,13 @@ static QImage::Format imageFormat(const PSDHeader &header, bool alpha)
     auto format = QImage::Format_Invalid;
     switch(header.color_mode) {
     case CM_RGB:
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         if (header.depth == 32) {
             format = header.channel_count < 4 || !alpha ? QImage::Format_RGBX32FPx4 : QImage::Format_RGBA32FPx4_Premultiplied;
         } else if (header.depth == 16) {
+#else
+        if (header.depth == 16 || header.depth == 32) {
+#endif
             format = header.channel_count < 4 || !alpha ? QImage::Format_RGBX64 : QImage::Format_RGBA64_Premultiplied;
         } else {
             format = header.channel_count < 4 || !alpha ? QImage::Format_RGB888 : QImage::Format_RGBA8888_Premultiplied;
@@ -813,9 +831,13 @@ static QImage::Format imageFormat(const PSDHeader &header, bool alpha)
         }
         break;
     case CM_GRAYSCALE:
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
         if (header.depth == 32) {
             format = !alpha ? QImage::Format_RGBX32FPx4 : QImage::Format_RGBA32FPx4_Premultiplied;
         } else if (header.depth == 16) {
+#else
+        if (header.depth == 32 || header.depth == 16) {
+#endif
             format = !alpha ? QImage::Format_Grayscale16 : QImage::Format_RGBA64_Premultiplied;
         } else {
             format = !alpha ? QImage::Format_Grayscale8 : QImage::Format_RGBA8888_Premultiplied;
@@ -1338,7 +1360,11 @@ bool PSDHandler::read(QImage *image)
         return false;
     }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<quint32> strides(header.height * header.channel_count, raw_count);
+#else
+    QVector<quint32> strides(header.height * header.channel_count, raw_count);
+#endif
     // Read the compressed stride sizes
     if (compression) {
         for (auto &&v : strides) {
@@ -1353,7 +1379,11 @@ bool PSDHandler::read(QImage *image)
     }
     // calculate the absolute file positions of each stride (required when a colorspace conversion should be done)
     auto device = stream.device();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<quint64> stridePositions(strides.size());
+#else
+    QVector<quint64> stridePositions(strides.size());
+#endif
     if (!stridePositions.isEmpty()) {
         stridePositions[0] = device->pos();
     }
@@ -1377,7 +1407,7 @@ bool PSDHandler::read(QImage *image)
         // CMYK with spots (e.g. CMYKA) ICC conversion to RGBA/RGBX
         QImage tmpCmyk;
         ScanLineConverter iccConv(img.format());
-#if !defined(PSD_NATIVE_CMYK_SUPPORT_DISABLED)
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0) && !defined(PSD_NATIVE_CMYK_SUPPORT_DISABLED)
         if (header.color_mode == CM_CMYK && img.format() != QImage::Format_CMYK8888) {
             auto tmpi = QImage(header.width, 1, QImage::Format_CMYK8888);
             if (setColorSpace(tmpi, irs)) {
@@ -1410,7 +1440,11 @@ bool PSDHandler::read(QImage *image)
                 } else if (header.depth == 16) {
                     planarToChunchy<quint16>(scanLine, rawStride.data(), header.width, c, header.channel_count);
                 } else if (header.depth == 32) {
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
                     planarToChunchy<float>(scanLine, rawStride.data(), header.width, c, header.channel_count);
+#else
+                    planarToChunchyFloatToUInt16<float>(scanLine, rawStride.data(), header.width, c, header.channel_count);
+#endif
                 }
             }
 
@@ -1435,7 +1469,11 @@ bool PSDHandler::read(QImage *image)
                     else if (header.depth == 16)
                         premulConversion<quint16>(scanLine, header.width, 3, header.channel_count, PremulConversion::PS2P);
                     else if (header.depth == 32)
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
                         premulConversion<float>(scanLine, header.width, 3, header.channel_count, PremulConversion::PS2P);
+#else
+                        premulConversion<quint16>(scanLine, header.width, 3, header.channel_count, PremulConversion::PS2P);
+#endif
                 }
                 if (header.color_mode == CM_GRAYSCALE) {
                     if (header.depth == 8)
@@ -1443,7 +1481,11 @@ bool PSDHandler::read(QImage *image)
                     else if (header.depth == 16)
                         premulConversion<quint16>(scanLine, header.width, 1, header.channel_count, PremulConversion::PS2P);
                     else if (header.depth == 32)
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
                         premulConversion<float>(scanLine, header.width, 1, header.channel_count, PremulConversion::PS2P);
+#else
+                        premulConversion<quint16>(scanLine, header.width, 1, header.channel_count, PremulConversion::PS2P);
+#endif
                 }
             }
 
@@ -1480,7 +1522,11 @@ bool PSDHandler::read(QImage *image)
                 else if (header.depth == 16)
                     rawChannelsCopy<quint16>(img.scanLine(y), imgChannels, psdScanline.data(), header.channel_count, header.width);
                 else if (header.depth == 32)
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
                     rawChannelsCopy<float>(img.scanLine(y), imgChannels, psdScanline.data(), header.channel_count, header.width);
+#else
+                    rawChannelsCopy<quint16>(img.scanLine(y), imgChannels, psdScanline.data(), header.channel_count, header.width);
+#endif
             }
             if (header.color_mode == CM_GRAYSCALE) {
                 for (auto c = 0; c < imgChannels; ++c) { // GRAYA to RGBA
@@ -1490,7 +1536,11 @@ bool PSDHandler::read(QImage *image)
                     else if (header.depth == 16)
                         rawChannelCopy<quint16>(img.scanLine(y), imgChannels, c, psdScanline.data(), header.channel_count, sc, header.width);
                     else if (header.depth == 32)
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
                         rawChannelCopy<float>(img.scanLine(y), imgChannels, c, psdScanline.data(), header.channel_count, sc, header.width);
+#else
+                        rawChannelCopy<quint16>(img.scanLine(y), imgChannels, c, psdScanline.data(), header.channel_count, sc, header.width);
+#endif
                 }
             }
         }
@@ -1523,7 +1573,11 @@ bool PSDHandler::read(QImage *image)
                         planarToChunchy<quint16>(scanLine, rawStride.data(), header.width, c, imgChannels);
                 } else if (header.depth == 32 && header.color_mode == CM_RGB) {
                     // 32-bits float images: RGB/RGBA
+#if (QT_VERSION >= QT_VERSION_CHECK(6, 2, 0))
                     planarToChunchy<float>(scanLine, rawStride.data(), header.width, c, imgChannels);
+#else
+                    planarToChunchyFloatToUInt16<float>(scanLine, rawStride.data(), header.width, c, imgChannels);
+#endif
                 } else if (header.depth == 32 && header.color_mode == CM_GRAYSCALE) {
                     if (imgChannels >= 3) { // GRAY to RGB
                         planarToChunchy<float>(scanLine, rawStride.data(), header.width, 0, imgChannels);
@@ -1556,11 +1610,13 @@ bool PSDHandler::read(QImage *image)
         if (header.color_mode == CM_RGB && header.depth == 32) {
             img.setColorSpace(QColorSpace(QColorSpace::SRgbLinear));
         }
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
         if (header.color_mode == CM_GRAYSCALE && header.depth == 32) {
             auto qs = QColorSpace(QPointF(0.3127, 0.3291), QColorSpace::TransferFunction::Linear);
             qs.setDescription(QStringLiteral("Linear grayscale"));
             img.setColorSpace(qs);
         }
+#endif
     }
 
     // XMP data
diff --git a/src/imageformats/pxr.cpp b/src/imageformats/pxr.cpp
index 668c7d2..6a80d8f 100644
--- a/src/imageformats/pxr.cpp
+++ b/src/imageformats/pxr.cpp
@@ -197,7 +197,7 @@ bool PXRHandler::read(QImage *image)
         return false;
     }
 
-    auto size = std::min(img.bytesPerLine(), header.strideSize());
+    auto size = std::min<qint64>(img.bytesPerLine(), header.strideSize());
     for (auto y = 0, h = img.height(); y < h; ++y) {
         auto line = reinterpret_cast<char*>(img.scanLine(y));
         if (d->read(line, size) != size) {
diff --git a/src/imageformats/ras.cpp b/src/imageformats/ras.cpp
index 5434744..08c38de 100644
--- a/src/imageformats/ras.cpp
+++ b/src/imageformats/ras.cpp
@@ -21,6 +21,10 @@ Q_LOGGING_CATEGORY(LOG_RASPLUGIN, "kf.imageformats.plugins.ras", QtDebugMsg)
 Q_LOGGING_CATEGORY(LOG_RASPLUGIN, "kf.imageformats.plugins.ras", QtWarningMsg)
 #endif
 
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
+
 /* *** RAS_MAX_IMAGE_WIDTH and RAS_MAX_IMAGE_HEIGHT ***
  * The maximum size in pixel allowed by the plugin.
  */
@@ -240,14 +244,22 @@ static bool LoadRAS(QDataStream &s, const RasHeader &ras, QImage &img)
         if (ras.ColorMapLength > 768) {
             return false;
         }
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         QList<quint8> palette(ras.ColorMapLength);
+#else
+        QVector<quint8> palette(ras.ColorMapLength);
+#endif
         for (quint32 i = 0; i < ras.ColorMapLength; ++i) {
             s >> palette[i];
             if (s.status() != QDataStream::Ok) {
                 return false;
             }
         }
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         QList<QRgb> colorTable;
+#else
+        QVector<QRgb> colorTable;
+#endif
         for (quint32 i = 0, n = ras.ColorMapLength / 3; i < n; ++i) {
             colorTable << qRgb(palette.at(i), palette.at(i + n), palette.at(i + 2 * n));
         }
@@ -258,7 +270,7 @@ static bool LoadRAS(QDataStream &s, const RasHeader &ras, QImage &img)
     }
 
     LineDecoder dec(s.device(), ras);
-    auto bytesPerLine = std::min(img.bytesPerLine(), qsizetype(rasLineSize));
+    auto bytesPerLine = std::min(qsizetype(img.bytesPerLine()), qsizetype(rasLineSize));
     for (quint32 y = 0; y < ras.Height; ++y) {
         auto rasLine = dec.readLine(rasLineSize);
         if (rasLine.size() != rasLineSize) {
diff --git a/src/imageformats/raw.cpp b/src/imageformats/raw.cpp
index f1cfcca..ae235ce 100644
--- a/src/imageformats/raw.cpp
+++ b/src/imageformats/raw.cpp
@@ -841,9 +841,11 @@ bool LoadRAW(QImageIOHandler *handler, QImage &img)
         if (params.output_color == 7) {
             img.setColorSpace(QColorSpace(QColorSpace::DisplayP3));
         }
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
         if (params.output_color == 8) {
             img.setColorSpace(QColorSpace(QColorSpace::Bt2020));
         }
+#endif
     }
 
     // *** Set the metadata
diff --git a/src/imageformats/rgb.cpp b/src/imageformats/rgb.cpp
index 41b9ac9..ccde4a0 100644
--- a/src/imageformats/rgb.cpp
+++ b/src/imageformats/rgb.cpp
@@ -31,13 +31,21 @@
 #include <QLoggingCategory>
 #include <QMap>
 
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
+
 #ifdef QT_DEBUG
 Q_LOGGING_CATEGORY(LOG_RGBPLUGIN, "kf.imageformats.plugins.rgb", QtDebugMsg)
 #else
 Q_LOGGING_CATEGORY(LOG_RGBPLUGIN, "kf.imageformats.plugins.rgb", QtWarningMsg)
 #endif
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 class RLEData : public QList<uchar>
+#else
+class RLEData : public QVector<uchar>
+#endif
 {
 public:
     RLEData()
@@ -70,7 +78,11 @@ public:
     {
     }
     uint insert(const uchar *d, uint l);
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<const RLEData *> vector();
+#else
+    QVector<const RLEData *> vector();
+#endif
     void setBaseOffset(uint o)
     {
         _offset = o;
@@ -129,7 +141,11 @@ private:
     QByteArray _data;
     QByteArray::Iterator _pos;
     RLEMap _rlemap;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<const RLEData *> _rlevector;
+#else
+    QVector<const RLEData *> _rlevector;
+#endif
     uint _numrows;
 
     bool readData(QImage &);
@@ -403,9 +419,17 @@ uint RLEMap::insert(const uchar *d, uint l)
     return QMap<RLEData, uint>::insert(data, _counter++).value();
 }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<const RLEData *> RLEMap::vector()
+#else
+QVector<const RLEData *> RLEMap::vector()
+#endif
 {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<const RLEData *> v(size());
+#else
+    QVector<const RLEData *> v(size());
+#endif
     for (Iterator it = begin(); it != end(); ++it) {
         v.replace(it.value(), &it.key());
     }
@@ -769,11 +793,15 @@ bool SGIImagePrivate::writeImage(const QImage &image)
 
     auto tcs = QColorSpace();
     auto tfmt = image.format();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     auto cs = image.colorSpace();
     if (cs.isValid() && cs.colorModel() == QColorSpace::ColorModel::Cmyk && tfmt == QImage::Format_CMYK8888) {
         tcs = QColorSpace(QColorSpace::SRgb);
         tfmt = QImage::Format_RGB32;
     } else if (hasAlpha && tfmt != QImage::Format_ARGB32) {
+#else
+    if (hasAlpha && tfmt != QImage::Format_ARGB32) {
+#endif
         tfmt = QImage::Format_ARGB32;
     } else if (!hasAlpha && tfmt != QImage::Format_RGB32) {
         tfmt = QImage::Format_RGB32;
diff --git a/src/imageformats/scanlineconverter.cpp b/src/imageformats/scanlineconverter.cpp
index bb6976d..0ee4f57 100644
--- a/src/imageformats/scanlineconverter.cpp
+++ b/src/imageformats/scanlineconverter.cpp
@@ -72,12 +72,18 @@ const uchar *ScanLineConverter::convertedScanLine(const QImage &image, qint32 y)
         if (!cs.isValid()) {
             cs = _defaultColorSpace;
         }
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
         if (tmp.depth() < 8 && cs.colorModel() == QColorSpace::ColorModel::Gray) {
             tmp.convertTo(QImage::Format_Grayscale8);
         }
         else if (tmp.depth() < 24 && cs.colorModel() == QColorSpace::ColorModel::Rgb) {
             tmp.convertTo(tmp.hasAlphaChannel() ? QImage::Format_ARGB32 : QImage::Format_RGB32);
         }
+#else
+        if (tmp.depth() < 24) {
+            tmp.convertTo(tmp.hasAlphaChannel() ? QImage::Format_ARGB32 : QImage::Format_RGB32);
+        }
+#endif
         tmp.setColorSpace(cs);
         tmp.convertToColorSpace(_colorSpace);
     }
diff --git a/src/imageformats/sct.cpp b/src/imageformats/sct.cpp
index 5f5f11b..d2c92c4 100644
--- a/src/imageformats/sct.cpp
+++ b/src/imageformats/sct.cpp
@@ -177,10 +177,12 @@ public:
     QImage::Format format() const
     {
         auto format = QImage::Format_Invalid;
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
         if (m_pb.colorCount() == 4) {
             if (m_pb.bitMask() == 15)
                 format = QImage::Format_CMYK8888;
         }
+#endif
         if (m_pb.colorCount() == 3) {
             if (m_pb.bitMask() == 7)
                 format = QImage::Format_RGB888;
diff --git a/src/imageformats/tga.cpp b/src/imageformats/tga.cpp
index c6746b1..8a253dc 100644
--- a/src/imageformats/tga.cpp
+++ b/src/imageformats/tga.cpp
@@ -31,6 +31,9 @@
 #include <QDateTime>
 #include <QImage>
 #include <QLoggingCategory>
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
 
 typedef quint32 uint;
 typedef quint16 ushort;
@@ -616,8 +619,16 @@ static bool LoadTGA(QIODevice *dev, const TgaHeader &tga, QImage &img)
 
     // Read palette.
     if (info.pal) {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         QList<QRgb> colorTable;
+#else
+        QVector<QRgb> colorTable;
+#endif
+#if QT_VERSION < QT_VERSION_CHECK(6, 8, 0)
+        colorTable.resize(tga.colormap_length);
+#else
         colorTable.resizeForOverwrite(tga.colormap_length);
+#endif
 
         if (tga.colormap_size == 32) {
             char data[4]; // BGRA
@@ -992,11 +1003,15 @@ bool TGAHandler::writeRGBA(const QImage &image)
     auto format = image.format();
     const bool hasAlpha = image.hasAlphaChannel();
     auto tcs = QColorSpace();
+#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
     auto cs = image.colorSpace();
     if (cs.isValid() && cs.colorModel() == QColorSpace::ColorModel::Cmyk && image.format() == QImage::Format_CMYK8888) {
         format = QImage::Format_RGB32;
         tcs = QColorSpace(QColorSpace::SRgb);
     } else if (hasAlpha && image.format() != QImage::Format_ARGB32) {
+#else
+    if (hasAlpha && image.format() != QImage::Format_ARGB32) {
+#endif
         format = QImage::Format_ARGB32;
     } else if (!hasAlpha && image.format() != QImage::Format_RGB32) {
         format = QImage::Format_RGB32;
diff --git a/src/imageformats/util_p.h b/src/imageformats/util_p.h
index 31498dc..a4bd543 100644
--- a/src/imageformats/util_p.h
+++ b/src/imageformats/util_p.h
@@ -14,9 +14,12 @@
 #include <limits>
 
 #include <QImage>
-#include <QImageIOHandler>
 #include <QIODevice>
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
+#include <QImageIOHandler>
+#endif
+
 // Default maximum width and height for the large image plugins.
 #ifndef KIF_LARGE_IMAGE_PIXEL_LIMIT
 #define KIF_LARGE_IMAGE_PIXEL_LIMIT 300000
@@ -59,9 +62,13 @@ static const int kMaxQVectorSize = std::numeric_limits<int>::max() - 32;
 inline QImage imageAlloc(const QSize &size, const QImage::Format &format)
 {
     QImage img;
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+    img = QImage(size, format);
+#else
     if (!QImageIOHandler::allocateImage(size, format, &img)) {
         img = QImage(); // paranoia
     }
+#endif
     return img;
 }
 
@@ -167,9 +174,11 @@ static QByteArray deviceRead(QIODevice *d, qint64 maxSize)
     QByteArray ba;
     while (ba.size() < maxSize) {
         auto toRead = std::min(blockSize, maxSize - ba.size());
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         if (toRead + ba.size() > QByteArray::maxSize()) {
             break;
         }
+#endif
         auto tmp = d->read(toRead);
         if (tmp.isEmpty()) {
             break;
diff --git a/src/imageformats/xcf.cpp b/src/imageformats/xcf.cpp
index 5a94dcd..1858c1b 100644
--- a/src/imageformats/xcf.cpp
+++ b/src/imageformats/xcf.cpp
@@ -12,17 +12,28 @@
 #include <QColorSpace>
 #include <QIODevice>
 #include <QImage>
-#include <QImageReader>
 #include <QList>
 #include <QLoggingCategory>
 #include <QPainter>
 #include <QStack>
 #include <QtEndian>
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
+#include <QImageReader>
+#endif
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QVector>
+#endif
+
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#define XCF_QT5_SUPPORT
+#endif
 
 #ifndef XCF_QT5_SUPPORT
 // Float images are not supported by Qt 5 and can be disabled in QT 6 to reduce memory usage.
 // Unfortunately enabling/disabling this define results in slightly different images, so leave the default if possible.
+#if QT_VERSION >= QT_VERSION_CHECK(6, 2, 0)
 #define USE_FLOAT_IMAGES // default uncommented
+#endif
 
 // Let's set a "reasonable" maximum size
 #ifndef XCF_MAX_IMAGE_WIDTH
@@ -111,7 +122,11 @@ struct RandomTable {
  * parallel processing on a tile-by-tile basis. Here, though,
  * we just read them in en-masse and store them in a matrix.
  */
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 typedef QList<QList<QImage>> Tiles;
+#else
+typedef QVector<QVector<QImage>> Tiles;
+#endif
 
 class XCFImageFormat
 {
@@ -493,7 +508,11 @@ public:
         qint32 tattoo; //!< (unique identifier?)
         quint32 unit; //!< Units of The GIMP (inch, mm, pica, etc...)
         qint32 num_colors = 0; //!< number of colors in an indexed image
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
         QList<QRgb> palette; //!< indexed image color palette
+#else
+        QVector<QRgb> palette; //!< indexed image color palette
+#endif
 
         int num_layers; //!< number of layers
         Layer layer; //!< most recently read layer
@@ -546,7 +565,11 @@ private:
     //! This table is used as a shared grayscale ramp to be set on grayscale
     //! images. This is because Qt does not differentiate between indexed and
     //! grayscale images.
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     static QList<QRgb> grayTable;
+#else
+    static QVector<QRgb> grayTable;
+#endif
 
     //! This table provides the add_pixel saturation values (i.e. 250 + 250 = 255).
     // static int add_lut[256][256]; - this is so lame waste of 256k of memory
@@ -647,7 +670,11 @@ bool XCFImageFormat::random_table_initialized;
 
 const RandomTable XCFImageFormat::randomTable{};
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
 QList<QRgb> XCFImageFormat::grayTable;
+#else
+QVector<QRgb> XCFImageFormat::grayTable;
+#endif
 
 bool XCFImageFormat::modeAffectsSourceAlpha(const quint32 type)
 {
@@ -963,7 +990,11 @@ bool XCFImageFormat::loadImageProperties(QDataStream &xcf_io, XCFImage &xcf_imag
         case PROP_PARASITES:
             while (!property.atEnd()) {
                 char *tag;
+#if QT_VERSION < QT_VERSION_CHECK(6, 7, 0)
+                quint32 size;
+#else
                 qint64 size;
+#endif
 
                 property.readBytes(tag, size);
 
@@ -996,7 +1027,11 @@ bool XCFImageFormat::loadImageProperties(QDataStream &xcf_io, XCFImage &xcf_imag
                 return false;
             }
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
             xcf_image.palette = QList<QRgb>();
+#else
+            xcf_image.palette = QVector<QRgb>();
+#endif
             xcf_image.palette.reserve(xcf_image.num_colors);
 
             for (int i = 0; i < xcf_image.num_colors; i++) {
@@ -1389,6 +1424,7 @@ bool XCFImageFormat::composeTiles(XCFImage &xcf_image)
     // tiles of 64x64 pixels. The required memory to build the image is at least doubled because tiles are loaded
     // and then the final image is created by copying the tiles inside it.
     // NOTE: on Windows to open a 10GiB image the plugin uses 28GiB of RAM
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     const qint64 channels = 1 + (layer.type == RGB_GIMAGE ? 2 : 0) + (layer.type == RGBA_GIMAGE ? 3 : 0);
     const int allocationLimit = QImageReader::allocationLimit();
     if (allocationLimit > 0) {
@@ -1397,6 +1433,7 @@ bool XCFImageFormat::composeTiles(XCFImage &xcf_image)
             return false;
         }
     }
+#endif
 #endif
 
     layer.image_tiles.resize(layer.nrows);
@@ -2071,7 +2108,11 @@ bool XCFImageFormat::loadLevel(QDataStream &xcf_io, Layer &layer, qint32 bpp, co
 
     const uint blockSize = TILE_WIDTH * TILE_HEIGHT * bpp * 1.5;
 
+#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
     QList<uchar> buffer;
+#else
+    QVector<uchar> buffer;
+#endif
     if (needConvert) {
         buffer.resize(blockSize * (bpp == 2 ? 2 : 1));
         buffer.fill(uchar());
-- 
2.52.0

