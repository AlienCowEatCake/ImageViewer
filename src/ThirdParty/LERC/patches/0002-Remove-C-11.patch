From a4ea599f94fa27f7d85e36ab991b7272b0f49632 Mon Sep 17 00:00:00 2001
From: Peter Zhigalov <peter.zhigalov@gmail.com>
Date: Sun, 28 Nov 2021 20:33:40 +0700
Subject: [PATCH 2/2] Remove C++11

---
 src/LercLib/BitMask.cpp          |   6 +-
 src/LercLib/BitMask.h            |   5 +-
 src/LercLib/Huffman.cpp          |  18 ++---
 src/LercLib/Huffman.h            |   9 +--
 src/LercLib/Lerc.cpp             | 113 ++++++++++++++++---------------
 src/LercLib/Lerc2.cpp            |  38 +++++++++--
 src/LercLib/Lerc2.h              |   7 +-
 src/LercLib/Lerc_c_api_impl.cpp  |  42 ++++++------
 src/LercLib/RLE.cpp              |   9 +--
 src/LercLib/include/Lerc_types.h |  58 ++++++++--------
 10 files changed, 165 insertions(+), 140 deletions(-)

diff --git a/src/LercLib/BitMask.cpp b/src/LercLib/BitMask.cpp
index 7c5b728..7e676e2 100644
--- a/src/LercLib/BitMask.cpp
+++ b/src/LercLib/BitMask.cpp
@@ -29,7 +29,7 @@ USING_NAMESPACE_LERC
 
 // -------------------------------------------------------------------------- ;
 
-BitMask::BitMask(const BitMask& src) : m_pBits(nullptr), m_nCols(0), m_nRows(0)
+BitMask::BitMask(const BitMask& src) : m_pBits(NULL), m_nCols(0), m_nRows(0)
 {
   SetSize(src.m_nCols, src.m_nRows);
   if (m_pBits && src.m_pBits)
@@ -92,7 +92,7 @@ bool BitMask::SetSize(int nCols, int nRows)
     m_nRows = nRows;
   }
 
-  return m_pBits != nullptr;
+  return m_pBits != NULL;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -122,7 +122,7 @@ int BitMask::CountValidBits() const
 void BitMask::Clear()
 {
   delete[] m_pBits;
-  m_pBits = nullptr;
+  m_pBits = NULL;
   m_nCols = 0;
   m_nRows = 0;
 }
diff --git a/src/LercLib/BitMask.h b/src/LercLib/BitMask.h
index 59331c8..7beb759 100644
--- a/src/LercLib/BitMask.h
+++ b/src/LercLib/BitMask.h
@@ -25,6 +25,7 @@ Contributors:  Thomas Maurer
 #define BITMASK_H
 
 #include "Defines.h"
+#include <cstdio>
 
 NAMESPACE_LERC_START
 
@@ -35,8 +36,8 @@ NAMESPACE_LERC_START
 class BitMask
 {
 public:
-  BitMask() : m_pBits(nullptr), m_nCols(0), m_nRows(0)  {}
-  BitMask(int nCols, int nRows) : m_pBits(nullptr), m_nCols(0), m_nRows(0) { SetSize(nCols, nRows); }
+  BitMask() : m_pBits(NULL), m_nCols(0), m_nRows(0)  {}
+  BitMask(int nCols, int nRows) : m_pBits(NULL), m_nCols(0), m_nRows(0) { SetSize(nCols, nRows); }
   BitMask(const BitMask& src);
   virtual ~BitMask()                        { Clear(); }
 
diff --git a/src/LercLib/Huffman.cpp b/src/LercLib/Huffman.cpp
index 7597ac7..a948b67 100644
--- a/src/LercLib/Huffman.cpp
+++ b/src/LercLib/Huffman.cpp
@@ -347,7 +347,7 @@ void Huffman::ClearTree()
     int n = 0;
     m_root->FreeTree(n);
     delete m_root;
-    m_root = nullptr;
+    m_root = NULL;
   }
 }
 
@@ -551,11 +551,11 @@ bool Huffman::BitUnStuffCodes(const Byte** ppByte, size_t& nBytesRemainingInOut,
 
 // -------------------------------------------------------------------------- ;
 
-//struct MyLargerThanOp
-//{
-//  inline bool operator() (const pair<int, unsigned int>& p0,
-//                          const pair<int, unsigned int>& p1)  { return p0.first > p1.first; }
-//};
+struct MyLargerThanOp
+{
+  inline bool operator() (const pair<int, unsigned int>& p0,
+                          const pair<int, unsigned int>& p1)  { return p0.first > p1.first; }
+};
 
 // -------------------------------------------------------------------------- ;
 
@@ -573,11 +573,7 @@ bool Huffman::ConvertCodesToCanonical()
       sortVec[i] = pair<int, unsigned int>(m_codeTable[i].first * tableSize - i, i);
 
   // sort descending
-  //std::sort(sortVec.begin(), sortVec.end(), MyLargerThanOp());
-
-  std::sort(sortVec.begin(), sortVec.end(),
-    [](const pair<int, unsigned int>& p0,
-       const pair<int, unsigned int>& p1) { return p0.first > p1.first; });
+  std::sort(sortVec.begin(), sortVec.end(), MyLargerThanOp());
 
   // create canonical codes and assign to orig code table
   unsigned int index = sortVec[0].second;
diff --git a/src/LercLib/Huffman.h b/src/LercLib/Huffman.h
index 2798600..b6f2b0e 100644
--- a/src/LercLib/Huffman.h
+++ b/src/LercLib/Huffman.h
@@ -25,6 +25,7 @@ Contributors:  Thomas Maurer
 #define HUFFMAN_H
 
 #include <vector>
+#include <cstdio>
 #include <cstring>
 #include <utility>
 #include "Defines.h"
@@ -34,7 +35,7 @@ NAMESPACE_LERC_START
 class Huffman
 {
 public:
-  Huffman() : m_maxHistoSize(1 << 15), m_maxNumBitsLUT(12), m_numBitsToSkipInTree(0), m_root(nullptr) {}
+  Huffman() : m_maxHistoSize(1 << 15), m_maxNumBitsLUT(12), m_numBitsToSkipInTree(0), m_root(NULL) {}
   ~Huffman() { Clear(); }
 
   // Limitation: We limit the max Huffman code length to 32 bit. If this happens, the function ComputeCodes()
@@ -71,7 +72,7 @@ private:
     {
       value = val;
       weight = -cnt;
-      child0 = child1 = nullptr;
+      child0 = child1 = NULL;
     }
 
     Node(Node* c0, Node* c1)    // new internal node from children c0 and c1
@@ -107,14 +108,14 @@ private:
       {
         child0->FreeTree(n);
         delete child0;
-        child0 = nullptr;
+        child0 = NULL;
         n--;
       }
       if (child1)
       {
         child1->FreeTree(n);
         delete child1;
-        child1 = nullptr;
+        child1 = NULL;
         n--;
       }
     }
diff --git a/src/LercLib/Lerc.cpp b/src/LercLib/Lerc.cpp
index 7784dbc..e2f5bfb 100644
--- a/src/LercLib/Lerc.cpp
+++ b/src/LercLib/Lerc.cpp
@@ -24,6 +24,7 @@ Contributors:  Thomas Maurer
 #include "Defines.h"
 #include "Lerc.h"
 #include "Lerc2.h"
+#include <cstdio>
 #include <typeinfo>
 #include <limits>
 
@@ -51,7 +52,7 @@ ErrCode Lerc::ComputeCompressedSize(const void* pData, int version, DataType dt,
   case DT_Double:  return ComputeCompressedSizeTempl((const double*)pData, version, nDim, nCols, nRows, nBands, nMasks, pValidBytes, maxZErr, numBytesNeeded);
 
   default:
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
   }
 }
 
@@ -72,7 +73,7 @@ ErrCode Lerc::Encode(const void* pData, int version, DataType dt, int nDim, int
   case DT_Double:  return EncodeTempl((const double*)pData, version, nDim, nCols, nRows, nBands, nMasks, pValidBytes, maxZErr, pBuffer, numBytesBuffer, numBytesWritten);
 
   default:
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
   }
 }
 
@@ -105,7 +106,7 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
       nMasks = 1;
 
     if (lercInfo.blobSize > (int)numBytesBlob)    // truncated blob, we won't be able to read this band
-      return ErrCode::BufferTooSmall;
+      return ErrCode_BufferTooSmall;
 
     struct Lerc2::HeaderInfo hdInfo;
     while (Lerc2::GetHeaderInfo(pLercBlob + lercInfo.blobSize, numBytesBlob - lercInfo.blobSize, hdInfo, bHasMask))
@@ -116,19 +117,19 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
        || (int)hdInfo.dt != (int)lercInfo.dt)
        //|| hdInfo.maxZError != lercInfo.maxZError)    // with the new bitplane compression, maxZError can vary between bands
       {
-        return ErrCode::Failed;
+        return ErrCode_Failed;
       }
 
       if (bHasMask || hdInfo.numValidPixel != lercInfo.numValidPixel)    // support mask per band
         nMasks = 2;
 
       if (lercInfo.blobSize > std::numeric_limits<int>::max() - hdInfo.blobSize)
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
       lercInfo.blobSize += hdInfo.blobSize;
 
       if (lercInfo.blobSize > (int)numBytesBlob)    // truncated blob, we won't be able to read this band
-        return ErrCode::BufferTooSmall;
+        return ErrCode_BufferTooSmall;
 
       lercInfo.nBands++;
       lercInfo.zMin = min(lercInfo.zMin, hdInfo.zMin);
@@ -138,7 +139,7 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
 
     lercInfo.nMasks = nMasks > 1 ? lercInfo.nBands : nMasks;
 
-    return ErrCode::Ok;
+    return ErrCode_Ok;
   }
 
 
@@ -158,7 +159,7 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
     size_t nBytesNeeded = 10 + 4 * sizeof(int) + 1 * sizeof(double);
 
     if (nBytesRead < nBytesNeeded)
-      return ErrCode::Failed;
+      return ErrCode_Failed;
 
     Byte* ptr = const_cast<Byte*>(pLercBlob);
     ptr += 10 + 2 * sizeof(int);
@@ -170,7 +171,7 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
     memcpy(&maxZErrorInFile, ptr, sizeof(double));
 
     if (height > 20000 || width > 20000)    // guard against bogus numbers; size limitation for old Lerc1
-      return ErrCode::Failed;
+      return ErrCode_Failed;
 
     lercInfo.nDim = 1;
     lercInfo.nCols = width;
@@ -184,7 +185,7 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
     while (lercInfo.blobSize + numBytesHeaderBand1 < numBytesBlob)    // means there could be another band
     {
       if (!cntZImg.read(&pByte, 1e12, false, onlyZPart))
-        return (lercInfo.nBands > 0) ? ErrCode::Ok : ErrCode::Failed;    // no other band, we are done
+        return (lercInfo.nBands > 0) ? ErrCode_Ok : ErrCode_Failed;    // no other band, we are done
 
       onlyZPart = true;
 
@@ -214,11 +215,11 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
       lercInfo.nMasks = numValidPixels < width * height ? 1 : 0;
     }
 
-    return ErrCode::Ok;
+    return ErrCode_Ok;
   }
 #endif
 
-  return ErrCode::Failed;
+  return ErrCode_Failed;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -238,7 +239,7 @@ ErrCode Lerc::Decode(const Byte* pLercBlob, unsigned int numBytesBlob, int nMask
   case DT_Double:  return DecodeTempl((double*)pData, pLercBlob, numBytesBlob, nDim, nCols, nRows, nBands, nMasks, pValidBytes);
 
   default:
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
   }
 }
 
@@ -258,7 +259,7 @@ ErrCode Lerc::ConvertToDouble(const void* pDataIn, DataType dt, size_t nDataValu
   //case DT_Double:  no convert double to double
 
   default:
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
   }
 }
 
@@ -272,15 +273,15 @@ ErrCode Lerc::ComputeCompressedSizeTempl(const T* pData, int version, int nDim,
   numBytesNeeded = 0;
 
   if (!pData || nDim <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0 || maxZErr < 0)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   unsigned int numBytesWritten = 0;
 
   return EncodeInternal(pData, version, nDim, nCols, nRows, nBands, nMasks, pValidBytes, maxZErr,
-    numBytesNeeded, nullptr, 0, numBytesWritten);
+    numBytesNeeded, NULL, 0, numBytesWritten);
 }
 
 // -------------------------------------------------------------------------- ;
@@ -292,10 +293,10 @@ ErrCode Lerc::EncodeTempl(const T* pData, int version, int nDim, int nCols, int
   numBytesWritten = 0;
 
   if (!pData || nDim <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0 || maxZErr < 0 || !pBuffer || !numBytesBuffer)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   unsigned int numBytesNeeded = 0;
 
@@ -310,10 +311,10 @@ ErrCode Lerc::DecodeTempl(T* pData, const Byte* pLercBlob, unsigned int numBytes
   int nDim, int nCols, int nRows, int nBands, int nMasks, Byte* pValidBytes)
 {
   if (!pData || nDim <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0 || !pLercBlob || !numBytesBlob)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   const Byte* pByte = pLercBlob;
   Lerc2::HeaderInfo hdInfo;
@@ -323,13 +324,13 @@ ErrCode Lerc::DecodeTempl(T* pData, const Byte* pLercBlob, unsigned int numBytes
   {
     LercInfo lercInfo;
     ErrCode errCode = GetLercInfo(pLercBlob, numBytesBlob, lercInfo);    // fast for Lerc2
-    if (errCode != ErrCode::Ok)
+    if (errCode != ErrCode_Ok)
       return errCode;
 
     const int nMasksEncoded = lercInfo.nMasks;    // 0, 1, or nBands
 
     if (nMasks < nMasksEncoded)
-      return ErrCode::WrongParam;
+      return ErrCode_WrongParam;
 
     size_t nBytesRemaining = numBytesBlob;
     Lerc2 lerc2;
@@ -340,10 +341,10 @@ ErrCode Lerc::DecodeTempl(T* pData, const Byte* pLercBlob, unsigned int numBytes
       if (((size_t)(pByte - pLercBlob) < numBytesBlob) && Lerc2::GetHeaderInfo(pByte, nBytesRemaining, hdInfo, bHasMask))
       {
         if (hdInfo.nDim != nDim || hdInfo.nCols != nCols || hdInfo.nRows != nRows)
-          return ErrCode::Failed;
+          return ErrCode_Failed;
 
         if ((pByte - pLercBlob) + (size_t)hdInfo.blobSize > numBytesBlob)
-          return ErrCode::BufferTooSmall;
+          return ErrCode_BufferTooSmall;
 
         size_t nPix = (size_t)iBand * nRows * nCols;
         T* arr = pData + nPix * nDim;
@@ -351,13 +352,13 @@ ErrCode Lerc::DecodeTempl(T* pData, const Byte* pLercBlob, unsigned int numBytes
         bool bGetMask = iBand < nMasks;
 
         if (bGetMask && !bitMask.SetSize(nCols, nRows))
-          return ErrCode::Failed;
+          return ErrCode_Failed;
 
-        if (!lerc2.Decode(&pByte, nBytesRemaining, arr, bGetMask ? bitMask.Bits() : nullptr))
-          return ErrCode::Failed;
+        if (!lerc2.Decode(&pByte, nBytesRemaining, arr, bGetMask ? bitMask.Bits() : NULL))
+          return ErrCode_Failed;
 
         if (bGetMask && !Convert(bitMask, pValidBytes + nPix))
-          return ErrCode::Failed;
+          return ErrCode_Failed;
       }
     }  // iBand
   }  // Lerc2
@@ -374,28 +375,28 @@ ErrCode Lerc::DecodeTempl(T* pData, const Byte* pLercBlob, unsigned int numBytes
     {
       unsigned int numBytesHeader = iBand == 0 ? numBytesHeaderBand0 : numBytesHeaderBand1;
       if ((size_t)(pByte - pLercBlob) + numBytesHeader > numBytesBlob)
-        return ErrCode::BufferTooSmall;
+        return ErrCode_BufferTooSmall;
 
       bool onlyZPart = iBand > 0;
       if (!zImg.read(&pByte1, 1e12, false, onlyZPart))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
       if (zImg.getWidth() != nCols || zImg.getHeight() != nRows)
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
       size_t nPix = (size_t)iBand * nRows * nCols;
       T* arr = pData + nPix;
-      Byte* pDst = iBand < nMasks ? pValidBytes + nPix : nullptr;
+      Byte* pDst = iBand < nMasks ? pValidBytes + nPix : NULL;
 
       if (!Convert(zImg, arr, pDst, iBand == 0))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
     }
 #else
-    return ErrCode::Failed;
+    return ErrCode_Failed;
 #endif
   }
 
-  return ErrCode::Ok;
+  return ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -411,14 +412,14 @@ ErrCode Lerc::EncodeInternal(const T* pData, int version, int nDim, int nCols, i
 
   Lerc2 lerc2;
   if (version >= 0 && !lerc2.SetEncoderToOldVersion(version))
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   Byte* pDst = pBuffer;
 
   const size_t nPix = (size_t)nCols * nRows;
   const size_t nElem = nPix * nDim;
 
-  const Byte* pPrevByteMask = nullptr;
+  const Byte* pPrevByteMask = NULL;
   vector<T> dataBuffer;
   vector<Byte> maskBuffer, prevMaskBuffer;
   BitMask bitMask;
@@ -430,22 +431,22 @@ ErrCode Lerc::EncodeInternal(const T* pData, int version, int nDim, int nCols, i
 
     // using the proper section of valid bytes, check this band for NaN
     const T* arr = pData + nElem * iBand;
-    const Byte* pByteMask = (nMasks > 0) ? (pValidBytes + ((nMasks > 1) ? nPix * iBand : 0)) : nullptr;
+    const Byte* pByteMask = (nMasks > 0) ? (pValidBytes + ((nMasks > 1) ? nPix * iBand : 0)) : NULL;
 
     ErrCode errCode = CheckForNaN(arr, nDim, nCols, nRows, pByteMask);
-    if (errCode != ErrCode::Ok && errCode != ErrCode::NaN)
+    if (errCode != ErrCode_Ok && errCode != ErrCode_NaN)
       return errCode;
 
-    if (errCode == ErrCode::NaN)    // found NaN values
+    if (errCode == ErrCode_NaN)    // found NaN values
     {
       if (!Resize(dataBuffer, nElem) || !Resize(maskBuffer, nPix))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
       memcpy(&dataBuffer[0], arr, nElem * sizeof(T));
       pByteMask ? memcpy(&maskBuffer[0], pByteMask, nPix) : memset(&maskBuffer[0], 1, nPix);
 
       if (!ReplaceNaNValues(dataBuffer, maskBuffer, nDim, nCols, nRows))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
       if (iBand > 0 && MasksDiffer(&maskBuffer[0], pPrevByteMask, nPix))
         bEncMsk = true;
@@ -472,30 +473,30 @@ ErrCode Lerc::EncodeInternal(const T* pData, int version, int nDim, int nCols, i
     if (bEncMsk)
     {
       if (pByteMask && !Convert(pByteMask, nCols, nRows, bitMask))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
-      if (!lerc2.Set(nDim, nCols, nRows, pByteMask ? bitMask.Bits() : nullptr))
-        return ErrCode::Failed;
+      if (!lerc2.Set(nDim, nCols, nRows, pByteMask ? bitMask.Bits() : NULL))
+        return ErrCode_Failed;
     }
 
     unsigned int nBytes = lerc2.ComputeNumBytesNeededToWrite(arr, maxZErr, bEncMsk);
     if (nBytes <= 0)
-      return ErrCode::Failed;
+      return ErrCode_Failed;
 
     numBytesNeeded += nBytes;
 
     if (pBuffer)
     {
       if ((size_t)(pDst - pBuffer) + nBytes > numBytesBuffer)    // check we have enough space left
-        return ErrCode::BufferTooSmall;
+        return ErrCode_BufferTooSmall;
 
       if (!lerc2.Encode(arr, &pDst))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
     }
   }
 
   numBytesWritten = (unsigned int)(pDst - pBuffer);
-  return ErrCode::Ok;
+  return ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -558,12 +559,12 @@ template<class T>
 ErrCode Lerc::ConvertToDoubleTempl(const T* pDataIn, size_t nDataValues, double* pDataOut)
 {
   if (!pDataIn || !nDataValues || !pDataOut)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   for (size_t k = 0; k < nDataValues; k++)
     pDataOut[k] = pDataIn[k];
 
-  return ErrCode::Ok;
+  return ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -571,10 +572,10 @@ ErrCode Lerc::ConvertToDoubleTempl(const T* pDataIn, size_t nDataValues, double*
 template<class T> ErrCode Lerc::CheckForNaN(const T* arr, int nDim, int nCols, int nRows, const Byte* pByteMask)
 {
   if (!arr || nDim <= 0 || nCols <= 0 || nRows <= 0)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   if (typeid(T) != typeid(double) && typeid(T) != typeid(float))
-    return ErrCode::Ok;
+    return ErrCode_Ok;
 
   for (size_t k = 0, i = 0; i < (size_t)nRows; i++)
   {
@@ -600,10 +601,10 @@ template<class T> ErrCode Lerc::CheckForNaN(const T* arr, int nDim, int nCols, i
     }
 
     if (bFoundNaN)
-      return ErrCode::NaN;
+      return ErrCode_NaN;
   }
 
-  return ErrCode::Ok;
+  return ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
diff --git a/src/LercLib/Lerc2.cpp b/src/LercLib/Lerc2.cpp
index bdb3a3a..2cd1790 100644
--- a/src/LercLib/Lerc2.cpp
+++ b/src/LercLib/Lerc2.cpp
@@ -172,7 +172,7 @@ unsigned int Lerc2::ComputeNumBytesNeededToWrite(const T* arr, double maxZError,
 
   m_maxValToQuantize = GetMaxValToQuantize(m_headerInfo.dt);
 
-  Byte* ptr = nullptr;    // only emulate the writing and just count the bytes needed
+  Byte* ptr = NULL;    // only emulate the writing and just count the bytes needed
   int nBytesTiling = 0;
 
   if (!ComputeMinMaxRanges(arr, m_zMinVec, m_zMaxVec))    // need this for diff encoding before WriteTiles()
@@ -978,8 +978,26 @@ bool Lerc2::TryRaiseMaxZError(const T* data, double& maxZError) const
   const HeaderInfo& hd = m_headerInfo;
   const int nDim = hd.nDim;
 
-  std::vector<double> roundErr, zErr, zErrCand = { 1, 0.5, 0.1, 0.05, 0.01, 0.005, 0.001, 0.0005, 0.0001 };
-  std::vector<int> zFac, zFacCand = { 1, 2, 10, 20, 100, 200, 1000, 2000, 10000 };
+  std::vector<double> roundErr, zErr, zErrCand;
+  zErrCand.push_back(1);
+  zErrCand.push_back(0.5);
+  zErrCand.push_back(0.1);
+  zErrCand.push_back(0.05);
+  zErrCand.push_back(0.01);
+  zErrCand.push_back(0.005);
+  zErrCand.push_back(0.001);
+  zErrCand.push_back(0.0005);
+  zErrCand.push_back(0.0001);
+  std::vector<int> zFac, zFacCand;
+  zFacCand.push_back(1);
+  zFacCand.push_back(2);
+  zFacCand.push_back(10);
+  zFacCand.push_back(20);
+  zFacCand.push_back(100);
+  zFacCand.push_back(200);
+  zFacCand.push_back(1000);
+  zFacCand.push_back(2000);
+  zFacCand.push_back(10000);
 
   for (size_t i = 0; i < zErrCand.size(); i++)
     if (zErrCand[i] / 2 > maxZError)
@@ -1878,7 +1896,7 @@ bool Lerc2::ReadTile(const Byte** ppByte, size_t& nBytesRemainingInOut, T* data,
         return false;
 
       double invScale = 2 * hd.maxZError;    // for int types this is int
-      const unsigned int* srcPtr = bufferVec.data();
+      const unsigned int* srcPtr = &(bufferVec[0]);
 
       if (bufferVec.size() == maxElementCount)    // all valid
       {
@@ -1987,6 +2005,14 @@ Lerc2::DataType Lerc2::GetDataType(T z)
 
 // -------------------------------------------------------------------------- ;
 
+struct MyLessThanOp
+{
+  inline bool operator() (const pair<unsigned int, unsigned int>& p0,
+                          const pair<unsigned int, unsigned int>& p1) { return p0.first < p1.first; }
+};
+
+// -------------------------------------------------------------------------- ;
+
 void Lerc2::SortQuantArray(const vector<unsigned int>& quantVec, vector<pair<unsigned int, unsigned int> >& sortedQuantVec)
 {
   int numElem = (int)quantVec.size();
@@ -1995,9 +2021,7 @@ void Lerc2::SortQuantArray(const vector<unsigned int>& quantVec, vector<pair<uns
   for (int i = 0; i < numElem; i++)
     sortedQuantVec[i] = pair<unsigned int, unsigned int>(quantVec[i], i);
 
-  std::sort(sortedQuantVec.begin(), sortedQuantVec.end(),
-    [](const pair<unsigned int, unsigned int>& p0,
-       const pair<unsigned int, unsigned int>& p1) { return p0.first < p1.first; });
+  std::sort(sortedQuantVec.begin(), sortedQuantVec.end(), MyLessThanOp());
 }
 
 // -------------------------------------------------------------------------- ;
diff --git a/src/LercLib/Lerc2.h b/src/LercLib/Lerc2.h
index 77afb71..f837b0a 100644
--- a/src/LercLib/Lerc2.h
+++ b/src/LercLib/Lerc2.h
@@ -26,6 +26,7 @@ Contributors:  Thomas Maurer
 
 #include <cfloat>
 #include <cmath>
+#include <cstdio>
 #include <algorithm>
 #include <string>
 #include "BitMask.h"
@@ -70,14 +71,14 @@ class Lerc2
 {
 public:
   Lerc2();
-  Lerc2(int nDim, int nCols, int nRows, const Byte* pMaskBits = nullptr);    // valid / invalid bits as byte array
+  Lerc2(int nDim, int nCols, int nRows, const Byte* pMaskBits = NULL);    // valid / invalid bits as byte array
   virtual ~Lerc2()  {}
 
   static int CurrentVersion() { return 5; }
 
   bool SetEncoderToOldVersion(int version);    // call this to encode compatible to an old decoder
 
-  bool Set(int nDim, int nCols, int nRows, const Byte* pMaskBits = nullptr);
+  bool Set(int nDim, int nCols, int nRows, const Byte* pMaskBits = NULL);
 
   template<class T>
   unsigned int ComputeNumBytesNeededToWrite(const T* arr, double maxZError, bool encodeMask);
@@ -115,7 +116,7 @@ public:
 
   /// dst buffer already allocated;  byte ptr is moved like a file pointer
   template<class T>
-  bool Decode(const Byte** ppByte, size_t& nBytesRemaining, T* arr, Byte* pMaskBits = nullptr);    // if mask ptr is not 0, mask bits are returned (even if all valid or same as previous)
+  bool Decode(const Byte** ppByte, size_t& nBytesRemaining, T* arr, Byte* pMaskBits = NULL);    // if mask ptr is not 0, mask bits are returned (even if all valid or same as previous)
 
 private:
 
diff --git a/src/LercLib/Lerc_c_api_impl.cpp b/src/LercLib/Lerc_c_api_impl.cpp
index 71e03df..954d2e2 100644
--- a/src/LercLib/Lerc_c_api_impl.cpp
+++ b/src/LercLib/Lerc_c_api_impl.cpp
@@ -42,15 +42,15 @@ lerc_status lerc_computeCompressedSizeForVersion(const void* pData, int version,
   int nMasks, const unsigned char* pValidBytes, double maxZErr, unsigned int* numBytes)
 {
   if (!numBytes)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   *numBytes = 0;
 
   if (!pData || dataType >= Lerc::DT_Undefined || nDim <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0 || maxZErr < 0)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::DataType dt = (Lerc::DataType)dataType;
   return (lerc_status)Lerc::ComputeCompressedSize(pData, version, dt, nDim, nCols, nRows, nBands, nMasks, pValidBytes, maxZErr, *numBytes);
@@ -72,15 +72,15 @@ lerc_status lerc_encodeForVersion(const void* pData, int version, unsigned int d
   unsigned int* nBytesWritten)
 {
   if (!nBytesWritten)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   *nBytesWritten = 0;
 
   if (!pData || dataType >= Lerc::DT_Undefined || nDim <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0 || maxZErr < 0 || !pOutBuffer || !outBufferSize)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::DataType dt = (Lerc::DataType)dataType;
   return (lerc_status)Lerc::Encode(pData, version, dt, nDim, nCols, nRows, nBands, nMasks, pValidBytes, maxZErr, pOutBuffer, outBufferSize, *nBytesWritten);
@@ -92,11 +92,11 @@ lerc_status lerc_getBlobInfo(const unsigned char* pLercBlob, unsigned int blobSi
   unsigned int* infoArray, double* dataRangeArray, int infoArraySize, int dataRangeArraySize)
 {
   if (!pLercBlob || !blobSize || (!infoArray && !dataRangeArray) || ((infoArraySize <= 0) && (dataRangeArraySize <= 0)))
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::LercInfo lercInfo;
   ErrCode errCode = Lerc::GetLercInfo(pLercBlob, blobSize, lercInfo);
-  if (errCode != ErrCode::Ok)
+  if (errCode != ErrCode_Ok)
     return (lerc_status)errCode;
 
   if (infoArray)
@@ -141,7 +141,7 @@ lerc_status lerc_getBlobInfo(const unsigned char* pLercBlob, unsigned int blobSi
       dataRangeArray[i++] = lercInfo.maxZError;
   }
 
-  return (lerc_status)ErrCode::Ok;
+  return (lerc_status)ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -150,18 +150,18 @@ lerc_status lerc_decode(const unsigned char* pLercBlob, unsigned int blobSize, i
   unsigned char* pValidBytes, int nDim, int nCols, int nRows, int nBands, unsigned int dataType, void* pData)
 {
   if (!pLercBlob || !blobSize || !pData || dataType >= Lerc::DT_Undefined || nDim <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::DataType dt = (Lerc::DataType)dataType;
 
   ErrCode errCode = Lerc::Decode(pLercBlob, blobSize, nMasks, pValidBytes, nDim, nCols, nRows, nBands, dt, pData);
-  if (errCode != ErrCode::Ok)
+  if (errCode != ErrCode_Ok)
     return (lerc_status)errCode;
 
-  return (lerc_status)ErrCode::Ok;
+  return (lerc_status)ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -170,23 +170,23 @@ lerc_status lerc_decodeToDouble(const unsigned char* pLercBlob, unsigned int blo
   unsigned char* pValidBytes, int nDim, int nCols, int nRows, int nBands, double* pData)
 {
   if (!pLercBlob || !blobSize || !pData || nDim <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::LercInfo lercInfo;
   ErrCode errCode;
-  if ((errCode = Lerc::GetLercInfo(pLercBlob, blobSize, lercInfo)) != ErrCode::Ok)
+  if ((errCode = Lerc::GetLercInfo(pLercBlob, blobSize, lercInfo)) != ErrCode_Ok)
     return (lerc_status)errCode;
 
   Lerc::DataType dt = lercInfo.dt;
   if (dt > Lerc::DT_Double)
-    return (lerc_status)ErrCode::Failed;
+    return (lerc_status)ErrCode_Failed;
 
   if (dt == Lerc::DT_Double)
   {
-    if ((errCode = Lerc::Decode(pLercBlob, blobSize, nMasks, pValidBytes, nDim, nCols, nRows, nBands, dt, pData)) != ErrCode::Ok)
+    if ((errCode = Lerc::Decode(pLercBlob, blobSize, nMasks, pValidBytes, nDim, nCols, nRows, nBands, dt, pData)) != ErrCode_Ok)
       return (lerc_status)errCode;
   }
   else
@@ -196,14 +196,14 @@ lerc_status lerc_decodeToDouble(const unsigned char* pLercBlob, unsigned int blo
     size_t nDataValues = nDim * nCols * nRows * nBands;
     void* ptrDec = (Byte*)pData + nDataValues * (sizeof(double) - sizeofDt[dt]);
 
-    if ((errCode = Lerc::Decode(pLercBlob, blobSize, nMasks, pValidBytes, nDim, nCols, nRows, nBands, dt, ptrDec)) != ErrCode::Ok)
+    if ((errCode = Lerc::Decode(pLercBlob, blobSize, nMasks, pValidBytes, nDim, nCols, nRows, nBands, dt, ptrDec)) != ErrCode_Ok)
       return (lerc_status)errCode;
 
-    if ((errCode = Lerc::ConvertToDouble(ptrDec, dt, nDataValues, pData)) != ErrCode::Ok)
+    if ((errCode = Lerc::ConvertToDouble(ptrDec, dt, nDataValues, pData)) != ErrCode_Ok)
       return (lerc_status)errCode;
   }
 
-  return (lerc_status)ErrCode::Ok;
+  return (lerc_status)ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
diff --git a/src/LercLib/RLE.cpp b/src/LercLib/RLE.cpp
index ed75f37..990c233 100644
--- a/src/LercLib/RLE.cpp
+++ b/src/LercLib/RLE.cpp
@@ -23,6 +23,7 @@ Contributors:  Thomas Maurer
 
 #include "Defines.h"
 #include "RLE.h"
+#include <cstdio>
 #include <cstring>
 
 USING_NAMESPACE_LERC
@@ -31,7 +32,7 @@ USING_NAMESPACE_LERC
 
 size_t RLE::computeNumBytesRLE(const Byte* arr, size_t numBytes) const
 {
-  if (arr == nullptr || numBytes == 0)
+  if (arr == NULL || numBytes == 0)
     return 0;
 
   const Byte* ptr = arr;
@@ -123,7 +124,7 @@ size_t RLE::computeNumBytesRLE(const Byte* arr, size_t numBytes) const
 bool RLE::compress(const Byte* arr, size_t numBytes,
                    Byte** arrRLE, size_t& numBytesRLE, bool verify) const
 {
-  if (arr == nullptr || numBytes == 0)
+  if (arr == NULL || numBytes == 0)
     return false;
 
   numBytesRLE = computeNumBytesRLE(arr, numBytes);
@@ -235,7 +236,7 @@ bool RLE::compress(const Byte* arr, size_t numBytes,
 
   if (verify)
   {
-    Byte* arr2 = nullptr;
+    Byte* arr2 = NULL;
     size_t numBytes2 = 0;
     if (!decompress(*arrRLE, numBytesRLE, &arr2, numBytes2) || numBytes2 != numBytes)
     {
@@ -282,7 +283,7 @@ bool RLE::decompress(const Byte* arrRLE, size_t nBytesRemainingIn, Byte** arr, s
 
   if (numBytes == 0)
   {
-    *arr = nullptr;
+    *arr = NULL;
     return false;
   }
 
diff --git a/src/LercLib/include/Lerc_types.h b/src/LercLib/include/Lerc_types.h
index 4fc784a..6d0a349 100644
--- a/src/LercLib/include/Lerc_types.h
+++ b/src/LercLib/include/Lerc_types.h
@@ -8,45 +8,45 @@
 
 namespace LercNS
 {
-  enum class ErrCode : int
+  enum ErrCode
   {
-    Ok = 0,
-    Failed,
-    WrongParam,
-    BufferTooSmall,
-    NaN
+    ErrCode_Ok = 0,
+    ErrCode_Failed,
+    ErrCode_WrongParam,
+    ErrCode_BufferTooSmall,
+    ErrCode_NaN
   };
 
-  enum class DataType : int
+  enum DataType
   {
-    dt_char = 0,
-    dt_uchar,
-    dt_short,
-    dt_ushort,
-    dt_int,
-    dt_uint,
-    dt_float,
-    dt_double
+    DataType_dt_char = 0,
+    DataType_dt_uchar,
+    DataType_dt_short,
+    DataType_dt_ushort,
+    DataType_dt_int,
+    DataType_dt_uint,
+    DataType_dt_float,
+    DataType_dt_double
   };
 
-  enum class InfoArrOrder : int
+  enum InfoArrOrder
   {
-    version = 0,
-    dataType,
-    nDim,
-    nCols,
-    nRows,
-    nBands,
-    nValidPixels,  // for 1st band
-    blobSize,
-    nMasks  // 0 - all valid, 1 - same mask for all bands, nBands - masks can differ between bands
+    InfoArrOrder_version = 0,
+    InfoArrOrder_dataType,
+    InfoArrOrder_nDim,
+    InfoArrOrder_nCols,
+    InfoArrOrder_nRows,
+    InfoArrOrder_nBands,
+    InfoArrOrder_nValidPixels,  // for 1st band
+    InfoArrOrder_blobSize,
+    InfoArrOrder_nMasks  // 0 - all valid, 1 - same mask for all bands, nBands - masks can differ between bands
   };
 
-  enum class DataRangeArrOrder : int
+  enum DataRangeArrOrder
   {
-    zMin = 0,
-    zMax,
-    maxZErrUsed
+    DataRangeArrOrder_zMin = 0,
+    DataRangeArrOrder_zMax,
+    DataRangeArrOrder_maxZErrUsed
   };
 
 }    // namespace
-- 
2.34.0

