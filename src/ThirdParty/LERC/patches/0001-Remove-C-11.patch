From c718ff53227c193b6f8002f16a330291abcd1cc0 Mon Sep 17 00:00:00 2001
From: Peter Zhigalov <peter.zhigalov@gmail.com>
Date: Sat, 23 Nov 2024 18:48:48 +0700
Subject: [PATCH 1/3] Remove C++11

---
 src/LercLib/BitMask.cpp          |   6 +-
 src/LercLib/BitMask.h            |   5 +-
 src/LercLib/Huffman.cpp          |  14 +-
 src/LercLib/Huffman.h            |   9 +-
 src/LercLib/Lerc.cpp             | 251 +++++++++++++++++--------------
 src/LercLib/Lerc.h               |   5 +-
 src/LercLib/Lerc2.cpp            |  41 ++++-
 src/LercLib/Lerc2.h              |   7 +-
 src/LercLib/Lerc_c_api_impl.cpp  |  64 ++++----
 src/LercLib/RLE.cpp              |   9 +-
 src/LercLib/fpl_Lerc2Ext.cpp     |  12 +-
 src/LercLib/fpl_Lerc2Ext.h       |  20 +--
 src/LercLib/include/Lerc_types.h |  68 ++++-----
 13 files changed, 289 insertions(+), 222 deletions(-)

diff --git a/src/LercLib/BitMask.cpp b/src/LercLib/BitMask.cpp
index 6e91d9b..b54e606 100644
--- a/src/LercLib/BitMask.cpp
+++ b/src/LercLib/BitMask.cpp
@@ -29,7 +29,7 @@ USING_NAMESPACE_LERC
 
 // -------------------------------------------------------------------------- ;
 
-BitMask::BitMask(const BitMask& src) : m_pBits(nullptr), m_nCols(0), m_nRows(0)
+BitMask::BitMask(const BitMask& src) : m_pBits(NULL), m_nCols(0), m_nRows(0)
 {
   SetSize(src.m_nCols, src.m_nRows);
   if (m_pBits && src.m_pBits)
@@ -92,7 +92,7 @@ bool BitMask::SetSize(int nCols, int nRows)
     m_nRows = nRows;
   }
 
-  return m_pBits != nullptr;
+  return m_pBits != NULL;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -122,7 +122,7 @@ int BitMask::CountValidBits() const
 void BitMask::Clear()
 {
   delete[] m_pBits;
-  m_pBits = nullptr;
+  m_pBits = NULL;
   m_nCols = 0;
   m_nRows = 0;
 }
diff --git a/src/LercLib/BitMask.h b/src/LercLib/BitMask.h
index 83c2e00..ae3ed3b 100644
--- a/src/LercLib/BitMask.h
+++ b/src/LercLib/BitMask.h
@@ -25,6 +25,7 @@ Contributors:  Thomas Maurer
 #define BITMASK_H
 
 #include "Defines.h"
+#include <cstdio>
 
 NAMESPACE_LERC_START
 
@@ -35,8 +36,8 @@ NAMESPACE_LERC_START
 class BitMask
 {
 public:
-  BitMask() : m_pBits(nullptr), m_nCols(0), m_nRows(0)  {}
-  BitMask(int nCols, int nRows) : m_pBits(nullptr), m_nCols(0), m_nRows(0) { SetSize(nCols, nRows); }
+  BitMask() : m_pBits(NULL), m_nCols(0), m_nRows(0)  {}
+  BitMask(int nCols, int nRows) : m_pBits(NULL), m_nCols(0), m_nRows(0) { SetSize(nCols, nRows); }
   BitMask(const BitMask& src);
   virtual ~BitMask()                        { Clear(); }
 
diff --git a/src/LercLib/Huffman.cpp b/src/LercLib/Huffman.cpp
index e64b170..60208e8 100644
--- a/src/LercLib/Huffman.cpp
+++ b/src/LercLib/Huffman.cpp
@@ -347,7 +347,7 @@ void Huffman::ClearTree()
     int n = 0;
     m_root->FreeTree(n);
     delete m_root;
-    m_root = nullptr;
+    m_root = NULL;
   }
 }
 
@@ -538,6 +538,13 @@ bool Huffman::BitUnStuffCodes(const Byte** ppByte, size_t& nBytesRemainingInOut,
 
 // -------------------------------------------------------------------------- ;
 
+struct MyLargerThanOp
+{
+  inline bool operator() (const pair<int, unsigned int>& p0,
+                          const pair<int, unsigned int>& p1)  { return p0.first > p1.first; }
+};
+
+// -------------------------------------------------------------------------- ;
 bool Huffman::ConvertCodesToCanonical()
 {
   // from the non canonical code book, create an array to be sorted in descending order:
@@ -550,9 +557,8 @@ bool Huffman::ConvertCodesToCanonical()
     if (m_codeTable[i].first > 0)
       sortVec[i] = pair<int, unsigned int>(m_codeTable[i].first * tableSize - i, i);
 
-  std::sort(sortVec.begin(), sortVec.end(),
-    [](const pair<int, unsigned int>& p0,
-       const pair<int, unsigned int>& p1) { return p0.first > p1.first; });
+  // sort descending
+  std::sort(sortVec.begin(), sortVec.end(), MyLargerThanOp());
 
   // create canonical codes and assign to orig code table
   unsigned int index = sortVec[0].second;
diff --git a/src/LercLib/Huffman.h b/src/LercLib/Huffman.h
index 80b7d94..02d6948 100644
--- a/src/LercLib/Huffman.h
+++ b/src/LercLib/Huffman.h
@@ -25,6 +25,7 @@ Contributors:  Thomas Maurer
 #define HUFFMAN_H
 
 #include <vector>
+#include <cstdio>
 #include <cstring>
 #include <utility>
 #include "Defines.h"
@@ -34,7 +35,7 @@ NAMESPACE_LERC_START
 class Huffman
 {
 public:
-  Huffman() : m_maxHistoSize(1 << 15), m_maxNumBitsLUT(12), m_numBitsToSkipInTree(0), m_root(nullptr) {}
+  Huffman() : m_maxHistoSize(1 << 15), m_maxNumBitsLUT(12), m_numBitsToSkipInTree(0), m_root(NULL) {}
   ~Huffman() { Clear(); }
 
   // Limitation: We limit the max Huffman code length to 32 bit. If this happens, the function ComputeCodes()
@@ -71,7 +72,7 @@ private:
     {
       value = val;
       weight = -cnt;
-      child0 = child1 = nullptr;
+      child0 = child1 = NULL;
     }
 
     Node(Node* c0, Node* c1)    // new internal node from children c0 and c1
@@ -107,14 +108,14 @@ private:
       {
         child0->FreeTree(n);
         delete child0;
-        child0 = nullptr;
+        child0 = NULL;
         n--;
       }
       if (child1)
       {
         child1->FreeTree(n);
         delete child1;
-        child1 = nullptr;
+        child1 = NULL;
         n--;
       }
     }
diff --git a/src/LercLib/Lerc.cpp b/src/LercLib/Lerc.cpp
index dcf8057..d9517c6 100644
--- a/src/LercLib/Lerc.cpp
+++ b/src/LercLib/Lerc.cpp
@@ -24,6 +24,7 @@ Contributors:  Thomas Maurer
 #include "Defines.h"
 #include "Lerc.h"
 #include "Lerc2.h"
+#include <cstdio>
 #include <typeinfo>
 #include <limits>
 #include <functional>
@@ -54,7 +55,7 @@ ErrCode Lerc::ComputeCompressedSize(const void* pData, int version, DataType dt,
   case DT_Double:  return ComputeCompressedSizeTempl((const double*)pData, LERC_ARG_1);
 
   default:
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
   }
 
 #undef LERC_ARG_1
@@ -80,7 +81,7 @@ ErrCode Lerc::Encode(const void* pData, int version, DataType dt, int nDepth, in
   case DT_Double:  return EncodeTempl((const double*)pData, LERC_ARG_2);
 
   default:
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
   }
 
 #undef LERC_ARG_2
@@ -119,14 +120,14 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
     if (pMins && pMaxs)
     {
       ErrCode errCode = GetRanges(pLercBlob, numBytesBlob, 0, lerc2Info, pMins, pMaxs, nElem);    // band 0
-      if (errCode != ErrCode::Ok)
+      if (errCode != ErrCode_Ok)
         return errCode;
     }
 
     lercInfo.nBands = 1;
 
     if (lercInfo.blobSize > (int)numBytesBlob)    // truncated blob, we won't be able to read this band
-      return ErrCode::BufferTooSmall;
+      return ErrCode_BufferTooSmall;
 
     struct Lerc2::HeaderInfo hdInfo;
     while (bTryNextBlob && Lerc2::GetHeaderInfo(pLercBlob + lercInfo.blobSize, numBytesBlob - lercInfo.blobSize, hdInfo, bHasMask))
@@ -136,7 +137,7 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
        || hdInfo.nRows != lercInfo.nRows
        || (int)hdInfo.dt != (int)lercInfo.dt)
       {
-        return ErrCode::Failed;
+        return ErrCode_Failed;
       }
 
       bTryNextBlob = (hdInfo.version <= 5) || (hdInfo.nBlobsMore > 0);
@@ -148,10 +149,10 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
         nMasks = 2;
 
       if (lercInfo.blobSize > std::numeric_limits<int>::max() - hdInfo.blobSize)    // guard against overflow
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
       if (lercInfo.blobSize + hdInfo.blobSize > (int)numBytesBlob)    // truncated blob, we won't be able to read this band
-        return ErrCode::BufferTooSmall;
+        return ErrCode_BufferTooSmall;
 
       lercInfo.zMin = min(lercInfo.zMin, hdInfo.zMin);
       lercInfo.zMax = max(lercInfo.zMax, hdInfo.zMax);
@@ -160,7 +161,7 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
       if (pMins && pMaxs)
       {
         ErrCode errCode = GetRanges(pLercBlob + lercInfo.blobSize, numBytesBlob - lercInfo.blobSize, lercInfo.nBands, hdInfo, pMins, pMaxs, nElem);
-        if (errCode != ErrCode::Ok)
+        if (errCode != ErrCode_Ok)
           return errCode;
       }
 
@@ -173,7 +174,7 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
     if (lercInfo.nUsesNoDataValue > 0)
       lercInfo.nUsesNoDataValue = lercInfo.nBands;    // if there is any noData used in any band, allow for different noData per band
 
-    return ErrCode::Ok;
+    return ErrCode_Ok;
   }
 
 
@@ -193,7 +194,7 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
     size_t nBytesNeeded = 10 + 4 * sizeof(int) + 1 * sizeof(double);
 
     if (nBytesRead < nBytesNeeded)
-      return ErrCode::Failed;
+      return ErrCode_Failed;
 
     const Byte* ptr = pLercBlob;
     ptr += 10 + 2 * sizeof(int);
@@ -205,7 +206,7 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
     memcpy(&maxZErrorInFile, ptr, sizeof(double));
 
     if (height > 20000 || width > 20000)    // guard against bogus numbers; size limitation for old Lerc1
-      return ErrCode::Failed;
+      return ErrCode_Failed;
 
     lercInfo.nDepth = 1;
     lercInfo.nCols = width;
@@ -219,7 +220,7 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
     while (lercInfo.blobSize + numBytesHeaderBand1 < numBytesBlob)    // means there could be another band
     {
       if (!cntZImg.read(&pByte, 1e12, false, onlyZPart))
-        return (lercInfo.nBands > 0) ? ErrCode::Ok : ErrCode::Failed;    // no other band, we are done
+        return (lercInfo.nBands > 0) ? ErrCode_Ok : ErrCode_Failed;    // no other band, we are done
 
       onlyZPart = true;
       lercInfo.blobSize = (int)(pByte - pLercBlob);
@@ -255,11 +256,11 @@ ErrCode Lerc::GetLercInfo(const Byte* pLercBlob, unsigned int numBytesBlob, stru
       lercInfo.nBands++;
     }
 
-    return ErrCode::Ok;
+    return ErrCode_Ok;
   }
 #endif
 
-  return ErrCode::Failed;
+  return ErrCode_Failed;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -281,7 +282,7 @@ ErrCode Lerc::Decode(const Byte* pLercBlob, unsigned int numBytesBlob, int nMask
   case DT_Double:  return DecodeTempl((double*)pData, LERC_ARG_3);
 
   default:
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
   }
 
 #undef LERC_ARG_3
@@ -303,7 +304,7 @@ ErrCode Lerc::ConvertToDouble(const void* pDataIn, DataType dt, size_t nDataValu
   //case DT_Double:  no convert double to double
 
   default:
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
   }
 }
 
@@ -318,10 +319,10 @@ ErrCode Lerc::ComputeCompressedSizeTempl(const T* pData, int version, int nDepth
   numBytesNeeded = 0;
 
   if (!pData || nDepth <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0 || maxZErr < 0)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   unsigned int numBytesWritten = 0;
 
@@ -330,15 +331,15 @@ ErrCode Lerc::ComputeCompressedSizeTempl(const T* pData, int version, int nDepth
     if (pUsesNoData)
       for (int i = 0; i < nBands; i++)
         if (pUsesNoData[i])
-          return ErrCode::WrongParam;
+          return ErrCode_WrongParam;
 
     return EncodeInternal_v5(pData, version, nDepth, nCols, nRows, nBands, nMasks, pValidBytes, maxZErr,
-      numBytesNeeded, nullptr, 0, numBytesWritten);
+      numBytesNeeded, NULL, 0, numBytesWritten);
   }
   else
   {
     return EncodeInternal(pData, version, nDepth, nCols, nRows, nBands, nMasks, pValidBytes, maxZErr,
-      numBytesNeeded, nullptr, 0, numBytesWritten, pUsesNoData, noDataValues);
+      numBytesNeeded, NULL, 0, numBytesWritten, pUsesNoData, noDataValues);
   }
 }
 
@@ -352,10 +353,10 @@ ErrCode Lerc::EncodeTempl(const T* pData, int version, int nDepth, int nCols, in
   numBytesWritten = 0;
 
   if (!pData || nDepth <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0 || maxZErr < 0 || !pBuffer || !numBytesBuffer)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   unsigned int numBytesNeeded = 0;
 
@@ -364,7 +365,7 @@ ErrCode Lerc::EncodeTempl(const T* pData, int version, int nDepth, int nCols, in
     if (pUsesNoData)
       for (int i = 0; i < nBands; i++)
         if (pUsesNoData[i])
-          return ErrCode::WrongParam;
+          return ErrCode_WrongParam;
 
     return EncodeInternal_v5(pData, version, nDepth, nCols, nRows, nBands, nMasks, pValidBytes, maxZErr,
       numBytesNeeded, pBuffer, numBytesBuffer, numBytesWritten);
@@ -384,10 +385,10 @@ ErrCode Lerc::DecodeTempl(T* pData, const Byte* pLercBlob, unsigned int numBytes
   unsigned char* pUsesNoData, double* noDataValues)
 {
   if (!pData || nDepth <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0 || !pLercBlob || !numBytesBlob)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   const Byte* pByte = pLercBlob;
   Lerc2::HeaderInfo hdInfo;
@@ -397,22 +398,22 @@ ErrCode Lerc::DecodeTempl(T* pData, const Byte* pLercBlob, unsigned int numBytes
   {
     LercInfo lercInfo;
     ErrCode errCode = GetLercInfo(pLercBlob, numBytesBlob, lercInfo);    // fast for Lerc2, does most checks
-    if (errCode != ErrCode::Ok)
+    if (errCode != ErrCode_Ok)
       return errCode;
 
     // caller must provide enough space for the masks that are there (e.g., if they differ between bands)
     if (nMasks < lercInfo.nMasks)    // 0, 1, or nBands
-      return ErrCode::WrongParam;
+      return ErrCode_WrongParam;
 
     // caller cannot ask for more bands than are there
     if (nBands > lercInfo.nBands)
-      return ErrCode::WrongParam;
+      return ErrCode_WrongParam;
 
     // if Lerc blob has noData values not covered by the mask, caller must get it (make sure caller cannot miss it)
     if (lercInfo.nUsesNoDataValue && nDepth > 1)
     {
       if (!pUsesNoData || !noDataValues)
-        return ErrCode::HasNoData;
+        return ErrCode_HasNoData;
 
       try
       {
@@ -421,7 +422,7 @@ ErrCode Lerc::DecodeTempl(T* pData, const Byte* pLercBlob, unsigned int numBytes
       }
       catch (...)
       {
-        return ErrCode::HasNoData;
+        return ErrCode_HasNoData;
       }
     }
 
@@ -434,10 +435,10 @@ ErrCode Lerc::DecodeTempl(T* pData, const Byte* pLercBlob, unsigned int numBytes
       if (((size_t)(pByte - pLercBlob) < numBytesBlob) && Lerc2::GetHeaderInfo(pByte, nBytesRemaining, hdInfo, bHasMask))
       {
         if (hdInfo.nDepth != nDepth || hdInfo.nCols != nCols || hdInfo.nRows != nRows)
-          return ErrCode::Failed;
+          return ErrCode_Failed;
 
         if ((pByte - pLercBlob) + (size_t)hdInfo.blobSize > numBytesBlob)
-          return ErrCode::BufferTooSmall;
+          return ErrCode_BufferTooSmall;
 
         size_t nPix = (size_t)iBand * nRows * nCols;
         T* arr = pData + nPix * nDepth;
@@ -445,10 +446,10 @@ ErrCode Lerc::DecodeTempl(T* pData, const Byte* pLercBlob, unsigned int numBytes
         bool bGetMask = iBand < nMasks;
 
         if (bGetMask && !bitMask.SetSize(nCols, nRows))
-          return ErrCode::Failed;
+          return ErrCode_Failed;
 
-        if (!lerc2.Decode(&pByte, nBytesRemaining, arr, bGetMask ? bitMask.Bits() : nullptr))
-          return ErrCode::Failed;
+        if (!lerc2.Decode(&pByte, nBytesRemaining, arr, bGetMask ? bitMask.Bits() : NULL))
+          return ErrCode_Failed;
 
         if (lercInfo.nUsesNoDataValue && nDepth > 1)
         {
@@ -456,11 +457,11 @@ ErrCode Lerc::DecodeTempl(T* pData, const Byte* pLercBlob, unsigned int numBytes
           noDataValues[iBand] = hdInfo.noDataValOrig;
 
           if (hdInfo.bPassNoDataValues && !RemapNoData(arr, bitMask, hdInfo))
-            return ErrCode::Failed;
+            return ErrCode_Failed;
         }
 
         if (bGetMask && !Convert(bitMask, pValidBytes + nPix))
-          return ErrCode::Failed;
+          return ErrCode_Failed;
       }
     }  // iBand
   }  // Lerc2
@@ -477,28 +478,28 @@ ErrCode Lerc::DecodeTempl(T* pData, const Byte* pLercBlob, unsigned int numBytes
     {
       unsigned int numBytesHeader = iBand == 0 ? numBytesHeaderBand0 : numBytesHeaderBand1;
       if ((size_t)(pByte - pLercBlob) + numBytesHeader > numBytesBlob)
-        return ErrCode::BufferTooSmall;
+        return ErrCode_BufferTooSmall;
 
       bool onlyZPart = iBand > 0;
       if (!zImg.read(&pByte1, 1e12, false, onlyZPart))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
       if (zImg.getWidth() != nCols || zImg.getHeight() != nRows)
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
       size_t nPix = (size_t)iBand * nRows * nCols;
       T* arr = pData + nPix;
-      Byte* pDst = iBand < nMasks ? pValidBytes + nPix : nullptr;
+      Byte* pDst = iBand < nMasks ? pValidBytes + nPix : NULL;
 
       if (!Convert(zImg, arr, pDst, iBand == 0))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
     }
 #else
-    return ErrCode::Failed;
+    return ErrCode_Failed;
 #endif
   }
 
-  return ErrCode::Ok;
+  return ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -514,14 +515,14 @@ ErrCode Lerc::EncodeInternal_v5(const T* pData, int version, int nDepth, int nCo
 
   Lerc2 lerc2;
   if (version >= 0 && !lerc2.SetEncoderToOldVersion(version))
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   Byte* pDst = pBuffer;
 
   const size_t nPix = (size_t)nCols * nRows;
   const size_t nElem = nPix * nDepth;
 
-  const Byte* pPrevByteMask = nullptr;
+  const Byte* pPrevByteMask = NULL;
   vector<T> dataBuffer;
   vector<Byte> maskBuffer, prevMaskBuffer;
   BitMask bitMask;
@@ -533,22 +534,22 @@ ErrCode Lerc::EncodeInternal_v5(const T* pData, int version, int nDepth, int nCo
 
     // using the proper section of valid bytes, check this band for NaN
     const T* arr = pData + nElem * iBand;
-    const Byte* pByteMask = (nMasks > 0) ? (pValidBytes + ((nMasks > 1) ? nPix * iBand : 0)) : nullptr;
+    const Byte* pByteMask = (nMasks > 0) ? (pValidBytes + ((nMasks > 1) ? nPix * iBand : 0)) : NULL;
 
     ErrCode errCode = CheckForNaN(arr, nDepth, nCols, nRows, pByteMask);
-    if (errCode != ErrCode::Ok && errCode != ErrCode::NaN)
+    if (errCode != ErrCode_Ok && errCode != ErrCode_NaN)
       return errCode;
 
-    if (errCode == ErrCode::NaN)    // found NaN values
+    if (errCode == ErrCode_NaN)    // found NaN values
     {
       if (!Resize(dataBuffer, nElem) || !Resize(maskBuffer, nPix))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
       memcpy(&dataBuffer[0], arr, nElem * sizeof(T));
       pByteMask ? memcpy(&maskBuffer[0], pByteMask, nPix) : memset(&maskBuffer[0], 1, nPix);
 
       if (!ReplaceNaNValues(dataBuffer, maskBuffer, nDepth, nCols, nRows))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
       if (iBand > 0 && MasksDiffer(&maskBuffer[0], pPrevByteMask, nPix))
         bEncMsk = true;
@@ -575,30 +576,30 @@ ErrCode Lerc::EncodeInternal_v5(const T* pData, int version, int nDepth, int nCo
     if (bEncMsk)
     {
       if (pByteMask && !Convert(pByteMask, nCols, nRows, bitMask))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
-      if (!lerc2.Set(nDepth, nCols, nRows, pByteMask ? bitMask.Bits() : nullptr))
-        return ErrCode::Failed;
+      if (!lerc2.Set(nDepth, nCols, nRows, pByteMask ? bitMask.Bits() : NULL))
+        return ErrCode_Failed;
     }
 
     unsigned int nBytes = lerc2.ComputeNumBytesNeededToWrite(arr, maxZErr, bEncMsk);
     if (nBytes <= 0)
-      return ErrCode::Failed;
+      return ErrCode_Failed;
 
     numBytesNeeded += nBytes;
 
     if (pBuffer)
     {
       if ((size_t)(pDst - pBuffer) + nBytes > numBytesBuffer)    // check we have enough space left
-        return ErrCode::BufferTooSmall;
+        return ErrCode_BufferTooSmall;
 
       if (!lerc2.Encode(arr, &pDst))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
     }
   }  // iBand
 
   numBytesWritten = (unsigned int)(pDst - pBuffer);
-  return ErrCode::Ok;
+  return ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -613,7 +614,7 @@ ErrCode Lerc::EncodeInternal(const T* pData, int version, int nDepth, int nCols,
   numBytesWritten = 0;
 
   if (version >= 0 && version <= 5)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   Lerc2 lerc2;
 
@@ -622,30 +623,30 @@ ErrCode Lerc::EncodeInternal(const T* pData, int version, int nDepth, int nCols,
 #endif
 
   if (version >= 0 && !lerc2.SetEncoderToOldVersion(version))
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   if (pUsesNoData && !noDataValues)
     for (int i = 0; i < nBands; i++)
       if (pUsesNoData[i])
-        return ErrCode::WrongParam;
+        return ErrCode_WrongParam;
 
   Byte* pDst = pBuffer;
 
   const size_t nPix = (size_t)nCols * nRows;
   const size_t nElem = nPix * nDepth;
 
-  const Byte* pPrevByteMask = nullptr;
+  const Byte* pPrevByteMask = NULL;
   vector<T> dataBuffer;
   vector<Byte> maskBuffer, prevMaskBuffer;
   BitMask bitMask;
 
   // allocate buffer for 1 band
   if (!Resize(dataBuffer, nElem) || !Resize(maskBuffer, nPix))
-    return ErrCode::Failed;
+    return ErrCode_Failed;
 
   bool bIsFltOrDbl = (typeid(T) == typeid(float) || typeid(T) == typeid(double));
   bool bAnyMaskModified = false;
-  ErrCode errCode = ErrCode::Ok;
+  ErrCode errCode = ErrCode_Ok;
 
   // loop over the bands
   for (int iBand = 0; iBand < nBands; iBand++)
@@ -654,7 +655,7 @@ ErrCode Lerc::EncodeInternal(const T* pData, int version, int nDepth, int nCols,
 
     // get the data and mask for this band
     const T* arrOrig = pData + nElem * iBand;
-    const Byte* pByteMaskOrig = (nMasks > 0) ? (pValidBytes + ((nMasks > 1) ? nPix * iBand : 0)) : nullptr;
+    const Byte* pByteMaskOrig = (nMasks > 0) ? (pValidBytes + ((nMasks > 1) ? nPix * iBand : 0)) : NULL;
 
     // copy to buffer so we can modify it
     memcpy(&dataBuffer[0], arrOrig, nElem * sizeof(T));
@@ -670,7 +671,7 @@ ErrCode Lerc::EncodeInternal(const T* pData, int version, int nDepth, int nCols,
     bool bIsFltDblAllInt = false;    // are the flt numbers all integer really? Double can be used for int numbers beyond 32 bit range
     bool bModifiedMask = false;    // can turn true if NaN or noData found at valid pixels
     bool bNeedNoData = false;    // can only turn true for nDepth > 1, and mix of valid and invalid values at the same pixel (special case)
-    errCode = ErrCode::Ok;
+    errCode = ErrCode_Ok;
 
     if (bIsFltOrDbl)    // if flt type, filter out NaN and / or noData values and update the mask if possible
     {
@@ -682,7 +683,7 @@ ErrCode Lerc::EncodeInternal(const T* pData, int version, int nDepth, int nCols,
       errCode = FilterNoData(dataBuffer, maskBuffer, nDepth, nCols, nRows, maxZErrL, bPassNoDataValue, noDataL, bModifiedMask, bNeedNoData);
     }
 
-    if (errCode != ErrCode::Ok)
+    if (errCode != ErrCode_Ok)
       return errCode;
 
     if (bModifiedMask)
@@ -708,40 +709,40 @@ ErrCode Lerc::EncodeInternal(const T* pData, int version, int nDepth, int nCols,
       bool bAllValid = !memchr(pByteMaskL, 0, nPix);
 
       if (!bAllValid && !Convert(pByteMaskL, nCols, nRows, bitMask))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
-      if (!lerc2.Set(nDepth, nCols, nRows, !bAllValid ? bitMask.Bits() : nullptr))
-        return ErrCode::Failed;
+      if (!lerc2.Set(nDepth, nCols, nRows, !bAllValid ? bitMask.Bits() : NULL))
+        return ErrCode_Failed;
     }
 
     // set other flags
 
     if (!lerc2.SetNoDataValues(bNeedNoData, noDataL, noDataOrig))
-      return ErrCode::Failed;
+      return ErrCode_Failed;
 
     if (!lerc2.SetNumBlobsMoreToCome(nBands - 1 - iBand))
-      return ErrCode::Failed;
+      return ErrCode_Failed;
 
     if (!lerc2.SetIsAllInt(bIsFltDblAllInt))
-      return ErrCode::Failed;
+      return ErrCode_Failed;
 
     unsigned int nBytes = lerc2.ComputeNumBytesNeededToWrite(arrL, maxZErrL, bEncMsk);
     if (nBytes <= 0)
-      return ErrCode::Failed;
+      return ErrCode_Failed;
 
     numBytesNeeded += nBytes;
 
     if (pBuffer)
     {
       if ((size_t)(pDst - pBuffer) + nBytes > numBytesBuffer)    // check we have enough space left
-        return ErrCode::BufferTooSmall;
+        return ErrCode_BufferTooSmall;
 
 #ifdef ENCODE_VERIFY
       const Byte* pDst0 = pDst;
 #endif
 
       if (!lerc2.Encode(arrL, &pDst))
-        return ErrCode::Failed;
+        return ErrCode_Failed;
 
 #ifdef ENCODE_VERIFY
       size_t blobSize = pDst - pDst0;
@@ -749,7 +750,7 @@ ErrCode Lerc::EncodeInternal(const T* pData, int version, int nDepth, int nCols,
       if (!DecodeAndCompareToInput(pDst0, blobSize, maxZErrL, lerc2Verify, arrL, pByteMaskL,
         arrOrig, pByteMaskOrig, bPassNoDataValue, noDataOrig, bModifiedMask))
       {
-        return ErrCode::Failed;
+        return ErrCode_Failed;
       }
 #endif
 
@@ -757,7 +758,7 @@ ErrCode Lerc::EncodeInternal(const T* pData, int version, int nDepth, int nCols,
   }  // iBand
 
   numBytesWritten = (unsigned int)(pDst - pBuffer);
-  return ErrCode::Ok;
+  return ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -820,12 +821,12 @@ template<class T>
 ErrCode Lerc::ConvertToDoubleTempl(const T* pDataIn, size_t nDataValues, double* pDataOut)
 {
   if (!pDataIn || !nDataValues || !pDataOut)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   for (size_t k = 0; k < nDataValues; k++)
     pDataOut[k] = pDataIn[k];
 
-  return ErrCode::Ok;
+  return ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -833,10 +834,10 @@ ErrCode Lerc::ConvertToDoubleTempl(const T* pDataIn, size_t nDataValues, double*
 template<class T> ErrCode Lerc::CheckForNaN(const T* arr, int nDepth, int nCols, int nRows, const Byte* pByteMask)
 {
   if (!arr || nDepth <= 0 || nCols <= 0 || nRows <= 0)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   if (typeid(T) != typeid(double) && typeid(T) != typeid(float))
-    return ErrCode::Ok;
+    return ErrCode_Ok;
 
   for (size_t k = 0, i = 0; i < (size_t)nRows; i++)
   {
@@ -862,10 +863,10 @@ template<class T> ErrCode Lerc::CheckForNaN(const T* arr, int nDepth, int nCols,
     }
 
     if (bFoundNaN)
-      return ErrCode::NaN;
+      return ErrCode_NaN;
   }
 
-  return ErrCode::Ok;
+  return ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -989,10 +990,10 @@ ErrCode Lerc::GetRanges(const Byte* pLercBlob, unsigned int numBytesBlob, int iB
   const int nDepth = lerc2Info.nDepth;
 
   if (nDepth <= 0 || iBand < 0 || !pMins || !pMaxs)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   if (nElem < ((size_t)iBand + 1) * (size_t)nDepth)
-    return ErrCode::BufferTooSmall;
+    return ErrCode_BufferTooSmall;
 
   if (nDepth == 1)
   {
@@ -1002,15 +1003,15 @@ ErrCode Lerc::GetRanges(const Byte* pLercBlob, unsigned int numBytesBlob, int iB
   else
   {
     if (lerc2Info.bPassNoDataValues)    // for nDepth > 1, and mix of valid and invalid values at same pixel, better fail
-      return ErrCode::HasNoData;        // than return min or max values that contain noData (to be fixed in next codec version)
+      return ErrCode_HasNoData;        // than return min or max values that contain noData (to be fixed in next codec version)
 
     // read header, mask, ranges, and copy them out
     Lerc2 lerc2;
     if (!lerc2.GetRanges(pLercBlob, numBytesBlob, &pMins[iBand * nDepth], &pMaxs[iBand * nDepth]))
-      return ErrCode::Failed;
+      return ErrCode_Failed;
   }
 
-  return ErrCode::Ok;
+  return ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -1215,23 +1216,23 @@ ErrCode Lerc::FilterNoData(std::vector<T>& dataBuffer, std::vector<Byte>& maskBu
   double& maxZError, bool bPassNoDataValue, double& noDataValue, bool& bModifiedMask, bool& bNeedNoData)
 {
   if (nDepth <= 0 || nCols <= 0 || nRows <= 0 || maxZError < 0)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   if ((dataBuffer.size() != (size_t)nDepth * nCols * nRows) || (maskBuffer.size() != (size_t)nCols * nRows))
-    return ErrCode::Failed;
+    return ErrCode_Failed;
 
   bModifiedMask = false;
   bNeedNoData = false;
 
   if (!bPassNoDataValue)    // nothing to do
-    return ErrCode::Ok;
+    return ErrCode_Ok;
 
   std::pair<double, double> typeRange;
   if (!GetTypeRange(dataBuffer[0], typeRange))
-    return ErrCode::Failed;
+    return ErrCode_Failed;
 
   if (noDataValue < typeRange.first || noDataValue > typeRange.second)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   T origNoData = (T)noDataValue;
 
@@ -1277,7 +1278,7 @@ ErrCode Lerc::FilterNoData(std::vector<T>& dataBuffer, std::vector<Byte>& maskBu
   if ((origNoData >= minVal - dist) && (origNoData <= maxVal + dist))
   {
     maxZError = 0.5;    // fall back to int lossless
-    return ErrCode::Ok;
+    return ErrCode_Ok;
   }
 
   if (bNeedNoData)
@@ -1328,7 +1329,7 @@ ErrCode Lerc::FilterNoData(std::vector<T>& dataBuffer, std::vector<Byte>& maskBu
   if (maxZError != maxZErrL)
     maxZError = maxZErrL;
 
-  return ErrCode::Ok;
+  return ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -1338,13 +1339,13 @@ ErrCode Lerc::FilterNoDataAndNaN(std::vector<T>& dataBuffer, std::vector<Byte>&
   double& maxZError, bool bPassNoDataValue, double& noDataValue, bool& bModifiedMask, bool& bNeedNoData, bool& bIsFltDblAllInt)
 {
   if (nDepth <= 0 || nCols <= 0 || nRows <= 0 || maxZError < 0)
-    return ErrCode::WrongParam;
+    return ErrCode_WrongParam;
 
   if ((dataBuffer.size() != (size_t)nDepth * nCols * nRows) || (maskBuffer.size() != (size_t)nCols * nRows))
-    return ErrCode::Failed;
+    return ErrCode_Failed;
 
   if (typeid(T) != typeid(double) && typeid(T) != typeid(float))    // only for float or double
-    return ErrCode::Failed;
+    return ErrCode_Failed;
 
   bModifiedMask = false;
   bNeedNoData = false;
@@ -1360,7 +1361,7 @@ ErrCode Lerc::FilterNoDataAndNaN(std::vector<T>& dataBuffer, std::vector<Byte>&
   if (bPassNoDataValue)
   {
     if (bIsFloat4 && (noDataValue < -FLT_MAX || noDataValue > FLT_MAX))
-      return ErrCode::WrongParam;
+      return ErrCode_WrongParam;
 
     origNoData = (T)noDataValue;
   }
@@ -1431,7 +1432,7 @@ ErrCode Lerc::FilterNoDataAndNaN(std::vector<T>& dataBuffer, std::vector<Byte>&
 
   if (bHasNaN && nDepth > 1 && bHasNoDataValuesLeft && !bPassNoDataValue)
   {
-    return ErrCode::NaN;    // Lerc cannot handle this case, cannot pick a noData value on the tile level
+    return ErrCode_NaN;    // Lerc cannot handle this case, cannot pick a noData value on the tile level
   }
 
   // now NaN's are gone, either moved to the mask or replaced by noData value
@@ -1453,7 +1454,7 @@ ErrCode Lerc::FilterNoDataAndNaN(std::vector<T>& dataBuffer, std::vector<Byte>&
   bIsFltDblAllInt = bAllInt;
 
   if (maxZErrL == 0)    // if flt lossless, we are done
-    return ErrCode::Ok;
+    return ErrCode_Ok;
 
   if (bPassNoDataValue)
   {
@@ -1463,7 +1464,7 @@ ErrCode Lerc::FilterNoDataAndNaN(std::vector<T>& dataBuffer, std::vector<Byte>&
     if ((origNoData >= minVal - dist) && (origNoData <= maxVal + dist))
     {
       maxZError = bAllInt ? 0.5 : 0;    // fall back to lossless
-      return ErrCode::Ok;
+      return ErrCode_Ok;
     }
   }
 
@@ -1516,7 +1517,7 @@ ErrCode Lerc::FilterNoDataAndNaN(std::vector<T>& dataBuffer, std::vector<Byte>&
   if (maxZError != maxZErrL)
     maxZError = maxZErrL;
 
-  return ErrCode::Ok;
+  return ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -1529,10 +1530,19 @@ bool Lerc::FindNewNoDataBelowValidMin(double minVal, double maxZErr, bool bAllIn
     std::vector<T> noDataCandVec;
 
     { // collect dist candidates
-      std::vector<double> distCandVec = { 4 * maxZErr, 1, 10, 100, 1000, 10000 };    // only int candidates
-
-      for (double dist : distCandVec)
+      std::vector<double> distCandVec;    // only int candidates
+      distCandVec.push_back(4 * maxZErr);
+      distCandVec.push_back(1);
+      distCandVec.push_back(10);
+      distCandVec.push_back(100);
+      distCandVec.push_back(1000);
+      distCandVec.push_back(10000);
+
+      for (size_t i = 0; i < distCandVec.size(); ++i)
+      {
+        double dist = distCandVec[i];
         noDataCandVec.push_back((T)(minVal - dist));
+      }
 
       double candForLargeMinVal = (minVal > 0 ? floor(minVal / 2) : minVal * 2);    // also int
       noDataCandVec.push_back((T)candForLargeMinVal);
@@ -1542,8 +1552,9 @@ bool Lerc::FindNewNoDataBelowValidMin(double minVal, double maxZErr, bool bAllIn
     std::sort(noDataCandVec.begin(), noDataCandVec.end(), std::greater<double>());
 
     // take the first one that satisfies the condition
-    for (T noDataVal : noDataCandVec)
+    for (size_t i = 0; i < noDataCandVec.size(); ++i)
     {
+      T noDataVal = noDataCandVec[i];
       if ((noDataVal > (T)lowIntLimit) && (noDataVal < (T)(minVal - 2 * maxZErr)) && IsInt(noDataVal))
       {
         newNoDataVal = noDataVal;
@@ -1556,10 +1567,23 @@ bool Lerc::FindNewNoDataBelowValidMin(double minVal, double maxZErr, bool bAllIn
     std::vector<T> noDataCandVec;
 
     { // dist candidates
-      std::vector<double> distCandVec = { 4 * maxZErr, 0.0001, 0.001, 0.01, 0.1, 1, 10, 100, 1000, 10000 };
-
-      for (double dist : distCandVec)
+      std::vector<double> distCandVec;
+      distCandVec.push_back(4 * maxZErr);
+      distCandVec.push_back(0.0001);
+      distCandVec.push_back(0.001);
+      distCandVec.push_back(0.01);
+      distCandVec.push_back(0.1);
+      distCandVec.push_back(1);
+      distCandVec.push_back(10);
+      distCandVec.push_back(100);
+      distCandVec.push_back(1000);
+      distCandVec.push_back(10000);
+
+      for (size_t i = 0; i < distCandVec.size(); ++i)
+      {
+        double dist = distCandVec[i];
         noDataCandVec.push_back((T)(minVal - dist));
+      }
 
       double candForLargeMinVal = (minVal > 0 ? minVal / 2 : minVal * 2);
       noDataCandVec.push_back((T)candForLargeMinVal);
@@ -1572,8 +1596,9 @@ bool Lerc::FindNewNoDataBelowValidMin(double minVal, double maxZErr, bool bAllIn
     T lowestVal = (T)(bIsFloat4 ? -FLT_MAX : -DBL_MAX);
 
     // take the first one that satisfies the condition
-    for (T noDataVal : noDataCandVec)
+    for (size_t i = 0; i < noDataCandVec.size(); ++i)
     {
+      T noDataVal = noDataCandVec[i];
       if ((noDataVal > lowestVal) && (noDataVal < (T)(minVal - 2 * maxZErr)))
       {
         newNoDataVal = noDataVal;
diff --git a/src/LercLib/Lerc.h b/src/LercLib/Lerc.h
index 715c30a..9baf3e4 100644
--- a/src/LercLib/Lerc.h
+++ b/src/LercLib/Lerc.h
@@ -23,6 +23,7 @@ Contributors:  Thomas Maurer
 
 #pragma once
 
+#include <cstdio>
 #include <cstring>
 #include <vector>
 #include "include/Lerc_types.h"
@@ -132,8 +133,8 @@ NAMESPACE_LERC_START
     static ErrCode GetLercInfo(const Byte* pLercBlob,       // Lerc blob to decode
       unsigned int numBytesBlob,   // size of Lerc blob in bytes
       struct LercInfo& lercInfo,
-      double* pMins = nullptr,     // pass array of size (nDepth * nBands) to get the min values per dimension and band
-      double* pMaxs = nullptr,     // same as pMins, to get the max values
+      double* pMins = NULL,     // pass array of size (nDepth * nBands) to get the min values per dimension and band
+      double* pMaxs = NULL,     // same as pMins, to get the max values
       size_t nElem = 0);           // (nDepth * nBands), if passed
 
     // setup outgoing arrays accordingly, then call Decode()
diff --git a/src/LercLib/Lerc2.cpp b/src/LercLib/Lerc2.cpp
index 8b85340..25df6c2 100644
--- a/src/LercLib/Lerc2.cpp
+++ b/src/LercLib/Lerc2.cpp
@@ -22,6 +22,7 @@ Contributors:   Thomas Maurer
                 Lucian Plesea (provided checksum code)
 */
 
+#include <cstdio>
 #include <typeinfo>
 #include "Defines.h"
 #include "Lerc2.h"
@@ -210,7 +211,7 @@ unsigned int Lerc2::ComputeNumBytesNeededToWrite(const T* arr, double maxZError,
 
   m_maxValToQuantize = GetMaxValToQuantize(m_headerInfo.dt);
 
-  Byte* ptr = nullptr;    // only emulate the writing and just count the bytes needed
+  Byte* ptr = NULL;    // only emulate the writing and just count the bytes needed
   int nBytesTiling = 0;
 
   if (!ComputeMinMaxRanges(arr, m_zMinVec, m_zMaxVec))    // need this for diff encoding before WriteTiles()
@@ -490,7 +491,7 @@ bool Lerc2::GetRanges(const Byte* pByte, size_t nBytesRemaining, double* pMins,
   }
 
   bool rv = false;
-  void* ptr = nullptr;
+  void* ptr = NULL;
 
   switch (m_headerInfo.dt)
   {
@@ -1173,8 +1174,26 @@ bool Lerc2::TryRaiseMaxZError(const T* data, double& maxZError) const
   const HeaderInfo& hd = m_headerInfo;
   const int nDepth = hd.nDepth;
 
-  std::vector<double> roundErr, zErr, zErrCand = { 1, 0.5, 0.1, 0.05, 0.01, 0.005, 0.001, 0.0005, 0.0001 };
-  std::vector<int> zFac, zFacCand = { 1, 2, 10, 20, 100, 200, 1000, 2000, 10000 };
+  std::vector<double> roundErr, zErr, zErrCand;
+  zErrCand.push_back(1);
+  zErrCand.push_back(0.5);
+  zErrCand.push_back(0.1);
+  zErrCand.push_back(0.05);
+  zErrCand.push_back(0.01);
+  zErrCand.push_back(0.005);
+  zErrCand.push_back(0.001);
+  zErrCand.push_back(0.0005);
+  zErrCand.push_back(0.0001);
+  std::vector<int> zFac, zFacCand;
+  zFacCand.push_back(1);
+  zFacCand.push_back(2);
+  zFacCand.push_back(10);
+  zFacCand.push_back(20);
+  zFacCand.push_back(100);
+  zFacCand.push_back(200);
+  zFacCand.push_back(1000);
+  zFacCand.push_back(2000);
+  zFacCand.push_back(10000);
 
   for (size_t i = 0; i < zErrCand.size(); i++)
     if (zErrCand[i] / 2 > maxZError)
@@ -2073,7 +2092,7 @@ bool Lerc2::ReadTile(const Byte** ppByte, size_t& nBytesRemainingInOut, T* data,
         return false;
 
       double invScale = 2 * hd.maxZError;    // for int types this is int
-      const unsigned int* srcPtr = bufferVec.data();
+      const unsigned int* srcPtr = &(bufferVec[0]);
 
       if (bufferVec.size() == maxElementCount)    // all valid
       {
@@ -2182,6 +2201,14 @@ Lerc2::DataType Lerc2::GetDataType(T z)
 
 // -------------------------------------------------------------------------- ;
 
+struct MyLessThanOp
+{
+  inline bool operator() (const pair<unsigned int, unsigned int>& p0,
+                          const pair<unsigned int, unsigned int>& p1) { return p0.first < p1.first; }
+};
+
+// -------------------------------------------------------------------------- ;
+
 void Lerc2::SortQuantArray(const vector<unsigned int>& quantVec, vector<pair<unsigned int, unsigned int> >& sortedQuantVec)
 {
   int numElem = (int)quantVec.size();
@@ -2190,9 +2217,7 @@ void Lerc2::SortQuantArray(const vector<unsigned int>& quantVec, vector<pair<uns
   for (int i = 0; i < numElem; i++)
     sortedQuantVec[i] = pair<unsigned int, unsigned int>(quantVec[i], i);
 
-  std::sort(sortedQuantVec.begin(), sortedQuantVec.end(),
-    [](const pair<unsigned int, unsigned int>& p0,
-       const pair<unsigned int, unsigned int>& p1) { return p0.first < p1.first; });
+  std::sort(sortedQuantVec.begin(), sortedQuantVec.end(), MyLessThanOp());
 }
 
 // -------------------------------------------------------------------------- ;
diff --git a/src/LercLib/Lerc2.h b/src/LercLib/Lerc2.h
index bacfeb4..0a6ea46 100644
--- a/src/LercLib/Lerc2.h
+++ b/src/LercLib/Lerc2.h
@@ -27,6 +27,7 @@ Contributors:  Thomas Maurer
 #include <cfloat>
 #include <cmath>
 #include <climits>
+#include <cstdio>
 #include <algorithm>
 #include <string>
 #include "BitMask.h"
@@ -72,14 +73,14 @@ class Lerc2
 {
 public:
   Lerc2();
-  Lerc2(int nDepth, int nCols, int nRows, const Byte* pMaskBits = nullptr);    // valid / invalid bits as byte array
+  Lerc2(int nDepth, int nCols, int nRows, const Byte* pMaskBits = NULL);    // valid / invalid bits as byte array
   virtual ~Lerc2()  {}
 
   static int CurrentVersion() { return 6; }
 
   bool SetEncoderToOldVersion(int version);    // call this to encode compatible to an old decoder
 
-  bool Set(int nDepth, int nCols, int nRows, const Byte* pMaskBits = nullptr);     // set mask and dimensions
+  bool Set(int nDepth, int nCols, int nRows, const Byte* pMaskBits = NULL);     // set mask and dimensions
 
   // v6
   bool SetNoDataValues(bool bNeedsNoDataVal, double noDataVal, double noDataValOrig);
@@ -133,7 +134,7 @@ public:
 
   /// dst buffer already allocated;  byte ptr is moved like a file pointer
   template<class T>
-  bool Decode(const Byte** ppByte, size_t& nBytesRemaining, T* arr, Byte* pMaskBits = nullptr);    // if mask ptr is not 0, mask bits are returned (even if all valid or same as previous)
+  bool Decode(const Byte** ppByte, size_t& nBytesRemaining, T* arr, Byte* pMaskBits = NULL);    // if mask ptr is not 0, mask bits are returned (even if all valid or same as previous)
 
 private:
 
diff --git a/src/LercLib/Lerc_c_api_impl.cpp b/src/LercLib/Lerc_c_api_impl.cpp
index ecf95bd..ff7e82d 100644
--- a/src/LercLib/Lerc_c_api_impl.cpp
+++ b/src/LercLib/Lerc_c_api_impl.cpp
@@ -43,19 +43,19 @@ lerc_status lerc_computeCompressedSizeForVersion(const void* pData, int version,
   int nMasks, const unsigned char* pValidBytes, double maxZErr, unsigned int* numBytes)
 {
   if (!numBytes)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   *numBytes = 0;
 
   if (!pData || dataType >= Lerc::DT_Undefined || nDepth <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0 || maxZErr < 0)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::DataType dt = (Lerc::DataType)dataType;
   return (lerc_status)Lerc::ComputeCompressedSize(pData, version, dt, nDepth, nCols, nRows, nBands, nMasks,
-    pValidBytes, maxZErr, *numBytes, nullptr, nullptr);
+    pValidBytes, maxZErr, *numBytes, NULL, NULL);
 }
 
 // -------------------------------------------------------------------------- ;
@@ -75,19 +75,19 @@ lerc_status lerc_encodeForVersion(const void* pData, int version, unsigned int d
   unsigned int* nBytesWritten)
 {
   if (!nBytesWritten)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   *nBytesWritten = 0;
 
   if (!pData || dataType >= Lerc::DT_Undefined || nDepth <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0 || maxZErr < 0 || !pOutBuffer || !outBufferSize)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::DataType dt = (Lerc::DataType)dataType;
   return (lerc_status)Lerc::Encode(pData, version, dt, nDepth, nCols, nRows, nBands, nMasks, pValidBytes,
-    maxZErr, pOutBuffer, outBufferSize, *nBytesWritten, nullptr, nullptr);
+    maxZErr, pOutBuffer, outBufferSize, *nBytesWritten, NULL, NULL);
 }
 
 // -------------------------------------------------------------------------- ;
@@ -96,11 +96,11 @@ lerc_status lerc_getBlobInfo(const unsigned char* pLercBlob, unsigned int blobSi
   unsigned int* infoArray, double* dataRangeArray, int infoArraySize, int dataRangeArraySize)
 {
   if (!pLercBlob || !blobSize || (!infoArray && !dataRangeArray) || ((infoArraySize <= 0) && (dataRangeArraySize <= 0)))
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::LercInfo lercInfo;
   ErrCode errCode = Lerc::GetLercInfo(pLercBlob, blobSize, lercInfo);
-  if (errCode != ErrCode::Ok)
+  if (errCode != ErrCode_Ok)
     return (lerc_status)errCode;
 
   if (infoArray)
@@ -154,7 +154,7 @@ lerc_status lerc_getBlobInfo(const unsigned char* pLercBlob, unsigned int blobSi
       dataRangeArray[i++] = lercInfo.maxZError;
   }
 
-  return (lerc_status)ErrCode::Ok;
+  return (lerc_status)ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -163,14 +163,14 @@ lerc_status lerc_getDataRanges(const unsigned char* pLercBlob, unsigned int blob
   int nDepth, int nBands, double* pMins, double* pMaxs)
 {
   if (!pLercBlob || !blobSize || !pMins || !pMaxs || nDepth <= 0 || nBands <= 0)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::LercInfo lercInfo;
   ErrCode errCode = Lerc::GetLercInfo(pLercBlob, blobSize, lercInfo, pMins, pMaxs, (size_t)nDepth * (size_t)nBands);
-  if (errCode != ErrCode::Ok)
+  if (errCode != ErrCode_Ok)
     return (lerc_status)errCode;
 
-  return (lerc_status)ErrCode::Ok;
+  return (lerc_status)ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
@@ -179,7 +179,7 @@ lerc_status lerc_decode(const unsigned char* pLercBlob, unsigned int blobSize, i
   unsigned char* pValidBytes, int nDepth, int nCols, int nRows, int nBands, unsigned int dataType, void* pData)
 {
   return lerc_decode_4D(pLercBlob, blobSize, nMasks, pValidBytes,
-    nDepth, nCols, nRows, nBands, dataType, pData, nullptr, nullptr);
+    nDepth, nCols, nRows, nBands, dataType, pData, NULL, NULL);
 }
 // -------------------------------------------------------------------------- ;
 
@@ -187,7 +187,7 @@ lerc_status lerc_decodeToDouble(const unsigned char* pLercBlob, unsigned int blo
   unsigned char* pValidBytes, int nDepth, int nCols, int nRows, int nBands, double* pData)
 {
   return lerc_decodeToDouble_4D(pLercBlob, blobSize, nMasks, pValidBytes,
-    nDepth, nCols, nRows, nBands, pData, nullptr, nullptr);
+    nDepth, nCols, nRows, nBands, pData, NULL, NULL);
 }
 
 // -------------------------------------------------------------------------- ;
@@ -197,15 +197,15 @@ lerc_status lerc_computeCompressedSize_4D(const void* pData, unsigned int dataTy
   int nMasks, const unsigned char* pValidBytes, double maxZErr, unsigned int* numBytes, const unsigned char* pUsesNoData, const double* noDataValues)
 {
   if (!numBytes)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   *numBytes = 0;
 
   if (!pData || dataType >= Lerc::DT_Undefined || nDepth <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0 || maxZErr < 0)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::DataType dt = (Lerc::DataType)dataType;
   return (lerc_status)Lerc::ComputeCompressedSize(pData, -1, dt, nDepth, nCols, nRows, nBands, nMasks,
@@ -219,15 +219,15 @@ lerc_status lerc_encode_4D(const void* pData, unsigned int dataType, int nDepth,
   unsigned int* nBytesWritten, const unsigned char* pUsesNoData, const double* noDataValues)
 {
   if (!nBytesWritten)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   *nBytesWritten = 0;
 
   if (!pData || dataType >= Lerc::DT_Undefined || nDepth <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0 || maxZErr < 0 || !pOutBuffer || !outBufferSize)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::DataType dt = (Lerc::DataType)dataType;
   return (lerc_status)Lerc::Encode(pData, -1, dt, nDepth, nCols, nRows, nBands, nMasks, pValidBytes,
@@ -241,10 +241,10 @@ lerc_status lerc_decode_4D(const unsigned char* pLercBlob, unsigned int blobSize
   unsigned char* pUsesNoData, double* noDataValues)
 {
   if (!pLercBlob || !blobSize || !pData || dataType >= Lerc::DT_Undefined || nDepth <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::DataType dt = (Lerc::DataType)dataType;
 
@@ -258,24 +258,24 @@ lerc_status lerc_decodeToDouble_4D(const unsigned char* pLercBlob, unsigned int
   unsigned char* pUsesNoData, double* noDataValues)
 {
   if (!pLercBlob || !blobSize || !pData || nDepth <= 0 || nCols <= 0 || nRows <= 0 || nBands <= 0)
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   if (!(nMasks == 0 || nMasks == 1 || nMasks == nBands) || (nMasks > 0 && !pValidBytes))
-    return (lerc_status)ErrCode::WrongParam;
+    return (lerc_status)ErrCode_WrongParam;
 
   Lerc::LercInfo lercInfo;
   ErrCode errCode;
-  if ((errCode = Lerc::GetLercInfo(pLercBlob, blobSize, lercInfo)) != ErrCode::Ok)
+  if ((errCode = Lerc::GetLercInfo(pLercBlob, blobSize, lercInfo)) != ErrCode_Ok)
     return (lerc_status)errCode;
 
   Lerc::DataType dt = lercInfo.dt;
   if (dt > Lerc::DT_Double)
-    return (lerc_status)ErrCode::Failed;
+    return (lerc_status)ErrCode_Failed;
 
   if (dt == Lerc::DT_Double)
   {
     if ((errCode = Lerc::Decode(pLercBlob, blobSize, nMasks, pValidBytes,
-      nDepth, nCols, nRows, nBands, dt, pData, pUsesNoData, noDataValues)) != ErrCode::Ok)
+      nDepth, nCols, nRows, nBands, dt, pData, pUsesNoData, noDataValues)) != ErrCode_Ok)
     {
       return (lerc_status)errCode;
     }
@@ -288,16 +288,16 @@ lerc_status lerc_decodeToDouble_4D(const unsigned char* pLercBlob, unsigned int
     void* ptrDec = (Byte*)pData + nDataValues * (sizeof(double) - sizeofDt[dt]);
 
     if ((errCode = Lerc::Decode(pLercBlob, blobSize, nMasks, pValidBytes,
-      nDepth, nCols, nRows, nBands, dt, ptrDec, pUsesNoData, noDataValues)) != ErrCode::Ok)
+      nDepth, nCols, nRows, nBands, dt, ptrDec, pUsesNoData, noDataValues)) != ErrCode_Ok)
     {
       return (lerc_status)errCode;
     }
 
-    if ((errCode = Lerc::ConvertToDouble(ptrDec, dt, nDataValues, pData)) != ErrCode::Ok)
+    if ((errCode = Lerc::ConvertToDouble(ptrDec, dt, nDataValues, pData)) != ErrCode_Ok)
       return (lerc_status)errCode;
   }
 
-  return (lerc_status)ErrCode::Ok;
+  return (lerc_status)ErrCode_Ok;
 }
 
 // -------------------------------------------------------------------------- ;
diff --git a/src/LercLib/RLE.cpp b/src/LercLib/RLE.cpp
index de0711a..67be874 100644
--- a/src/LercLib/RLE.cpp
+++ b/src/LercLib/RLE.cpp
@@ -23,6 +23,7 @@ Contributors:  Thomas Maurer
 
 #include "Defines.h"
 #include "RLE.h"
+#include <cstdio>
 #include <cstring>
 
 USING_NAMESPACE_LERC
@@ -31,7 +32,7 @@ USING_NAMESPACE_LERC
 
 size_t RLE::computeNumBytesRLE(const Byte* arr, size_t numBytes) const
 {
-  if (arr == nullptr || numBytes == 0)
+  if (arr == NULL || numBytes == 0)
     return 0;
 
   const Byte* ptr = arr;
@@ -123,7 +124,7 @@ size_t RLE::computeNumBytesRLE(const Byte* arr, size_t numBytes) const
 bool RLE::compress(const Byte* arr, size_t numBytes,
                    Byte** arrRLE, size_t& numBytesRLE, bool verify) const
 {
-  if (arr == nullptr || numBytes == 0)
+  if (arr == NULL || numBytes == 0)
     return false;
 
   numBytesRLE = computeNumBytesRLE(arr, numBytes);
@@ -235,7 +236,7 @@ bool RLE::compress(const Byte* arr, size_t numBytes,
 
   if (verify)
   {
-    Byte* arr2 = nullptr;
+    Byte* arr2 = NULL;
     size_t numBytes2 = 0;
     if (!decompress(*arrRLE, numBytesRLE, &arr2, numBytes2) || numBytes2 != numBytes)
     {
@@ -282,7 +283,7 @@ bool RLE::decompress(const Byte* arrRLE, size_t nBytesRemainingIn, Byte** arr, s
 
   if (numBytes == 0)
   {
-    *arr = nullptr;
+    *arr = NULL;
     return false;
   }
 
diff --git a/src/LercLib/fpl_Lerc2Ext.cpp b/src/LercLib/fpl_Lerc2Ext.cpp
index 0f07642..5411618 100644
--- a/src/LercLib/fpl_Lerc2Ext.cpp
+++ b/src/LercLib/fpl_Lerc2Ext.cpp
@@ -393,8 +393,9 @@ int LosslessFPCompression::compressedLength() const
 {
   int ret = 1; // predictor code
 
-  for (auto b : m_data_slice->m_buffers)
+  for (size_t i = 0; i < m_data_slice->m_buffers.size(); ++i)
   {
+    outBlockBuffer * b = m_data_slice->m_buffers[i];
     ret += b->compressed_size;
     ret += 6; // 2 bytes plus compr. size. We can use 1 byte in place of 2 by packing level and byte index.
   }
@@ -407,8 +408,9 @@ bool LosslessFPCompression::EncodeHuffmanFlt(unsigned char ** ppByte)
   memcpy(*ppByte, &(m_data_slice->m_predictor_code), sizeof(m_data_slice->m_predictor_code));
   *ppByte += sizeof(m_data_slice->m_predictor_code);
 
-  for (auto b : m_data_slice->m_buffers)
+  for (size_t i = 0; i < m_data_slice->m_buffers.size(); ++i)
   {
+      outBlockBuffer * b = m_data_slice->m_buffers[i];
       memcpy(*ppByte, &(b->byte_index), sizeof(b->byte_index));
       *ppByte += sizeof(b->byte_index);
       memcpy(*ppByte, &(b->best_level), sizeof(b->best_level));
@@ -419,8 +421,9 @@ bool LosslessFPCompression::EncodeHuffmanFlt(unsigned char ** ppByte)
       *ppByte += b->compressed_size;
   }
 
-  for (auto v : m_data_slice->m_buffers)
+  for (size_t i = 0; i < m_data_slice->m_buffers.size(); ++i)
   {
+    outBlockBuffer * v = m_data_slice->m_buffers[i];
     delete v;
   }
 
@@ -438,8 +441,9 @@ bool LosslessFPCompression::ComputeHuffmanCodesFlt(const void* input, bool bIsDo
     {
       // we decided not to write compressed output last time.
       // in this case, old compressed content must be removed.
-      for (auto v : m_data_slice->m_buffers)
+      for (size_t i = 0; i < m_data_slice->m_buffers.size(); ++i)
       {
+        outBlockBuffer * v = m_data_slice->m_buffers[i];
         delete v;
       }
 
diff --git a/src/LercLib/fpl_Lerc2Ext.h b/src/LercLib/fpl_Lerc2Ext.h
index 90c57cd..ed229c7 100644
--- a/src/LercLib/fpl_Lerc2Ext.h
+++ b/src/LercLib/fpl_Lerc2Ext.h
@@ -54,13 +54,14 @@ private:
       best_level = 0;
     }
 
-    outBlockBuffer(const outBlockBuffer&) = delete;             // disable copy constructor
-    outBlockBuffer& operator=(const outBlockBuffer&) = delete;  // disable assignment
-
     ~outBlockBuffer()
     {
       free(compressed);
     }
+
+  private:
+    outBlockBuffer(const outBlockBuffer&);             // disable copy constructor
+    outBlockBuffer& operator=(const outBlockBuffer&);  // disable assignment
   };
 
   struct compressedDataSlice
@@ -73,18 +74,19 @@ private:
       m_predictor_code = PREDICTOR_UNKNOWN;
     }
 
-    compressedDataSlice(const compressedDataSlice&) = delete;             // disable copy constructor
-    compressedDataSlice& operator=(const compressedDataSlice&) = delete;  // disable assignment
-
     ~compressedDataSlice()
     {
-      for (auto b : m_buffers)
+      for (size_t i = 0; i < m_buffers.size(); ++i)
       {
-        delete b;
+        delete m_buffers[i];
       }
 
       m_buffers.clear();
     }
+
+  private:
+    compressedDataSlice(const compressedDataSlice&);             // disable copy constructor
+    compressedDataSlice& operator=(const compressedDataSlice&);  // disable assignment
   };
 
   compressedDataSlice * m_data_slice;
@@ -98,7 +100,7 @@ private:
 
 
 public:
-  LosslessFPCompression() : m_data_slice (nullptr) { }
+  LosslessFPCompression() : m_data_slice (NULL) { }
   ~LosslessFPCompression();
 
   bool ComputeHuffmanCodesFlt(const void * pInput, bool nIsDouble, int iCols, int iRows, int iDepth);
diff --git a/src/LercLib/include/Lerc_types.h b/src/LercLib/include/Lerc_types.h
index 83d1d78..cbca555 100644
--- a/src/LercLib/include/Lerc_types.h
+++ b/src/LercLib/include/Lerc_types.h
@@ -8,50 +8,50 @@
 
 namespace LercNS
 {
-  enum class ErrCode : int
+  enum ErrCode
   {
-    Ok = 0,
-    Failed,
-    WrongParam,
-    BufferTooSmall,
-    NaN,
-    HasNoData
+    ErrCode_Ok = 0,
+    ErrCode_Failed,
+    ErrCode_WrongParam,
+    ErrCode_BufferTooSmall,
+    ErrCode_NaN,
+    ErrCode_HasNoData
   };
 
-  enum class DataType : int
+  enum DataType
   {
-    dt_char = 0,
-    dt_uchar,
-    dt_short,
-    dt_ushort,
-    dt_int,
-    dt_uint,
-    dt_float,
-    dt_double
+    DataType_dt_char = 0,
+    DataType_dt_uchar,
+    DataType_dt_short,
+    DataType_dt_ushort,
+    DataType_dt_int,
+    DataType_dt_uint,
+    DataType_dt_float,
+    DataType_dt_double
   };
 
-  enum class InfoArrOrder : int
+  enum InfoArrOrder
   {
-    version = 0,    // codec version
-    dataType,
-    nDim,    // = nDepth (we renamed nDim to nDepth but don't want to break anything)
-    nCols,
-    nRows,
-    nBands,
-    nValidPixels,  // for 1st band
-    blobSize,
-    nMasks,  // 0 - all valid, 1 - same mask for all bands, nBands - masks can differ between bands
-    nDepth,  // = nDim (we renamed nDim to nDepth but don't want to break anything)
-    nUsesNoDataValue,  // 0 - no noData value used, nBands - noData value used in 1 or more bands (only possible for nDepth > 1)
-    _last
+    InfoArrOrder_version = 0,    // codec version
+    InfoArrOrder_dataType,
+    InfoArrOrder_nDim,    // = nDepth (we renamed nDim to nDepth but don't want to break anything)
+    InfoArrOrder_nCols,
+    InfoArrOrder_nRows,
+    InfoArrOrder_nBands,
+    InfoArrOrder_nValidPixels,  // for 1st band
+    InfoArrOrder_blobSize,
+    InfoArrOrder_nMasks,  // 0 - all valid, 1 - same mask for all bands, nBands - masks can differ between bands
+    InfoArrOrder_nDepth,  // = nDim (we renamed nDim to nDepth but don't want to break anything)
+    InfoArrOrder_nUsesNoDataValue,  // 0 - no noData value used, nBands - noData value used in 1 or more bands (only possible for nDepth > 1)
+    InfoArrOrder__last
   };
 
-  enum class DataRangeArrOrder : int
+  enum DataRangeArrOrder
   {
-    zMin = 0,
-    zMax,
-    maxZErrUsed,
-    _last
+    DataRangeArrOrder_zMin = 0,
+    DataRangeArrOrder_zMax,
+    DataRangeArrOrder_maxZErrUsed,
+    DataRangeArrOrder__last
   };
 
 }    // namespace
-- 
2.47.0

